This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
effect-angular-effect-platform-angular-v0.0.7/
  .codex/
    config.toml
  .github/
    workflows/
      prepare_release_pr.yml
      release.yml
  .vscode/
    extensions.json
    launch.json
    mcp.json
    tasks.json
  conductor/
    archive/
      effect_rpc_angular_query_helpers_20260130/
        index.md
        metadata.json
        plan.md
        spec.md
      oss_project_infra_20260130/
        notes/
          knope-release-workflow.md
          readme-context-audit.md
        index.md
        metadata.json
        plan.md
        spec.md
      start_effect_platform_angular_httpclient_20260128/
        index.md
        metadata.json
        plan.md
        spec.md
    code_styleguides/
      general.md
      html-css.md
      typescript.md
    index.md
    product-guidelines.md
    product.md
    setup_state.json
    tech-stack.md
    tracks.md
    workflow.md
  projects/
    effect-angular-query/
      src/
        lib/
          effect-rpc-query-client.spec.ts
          effect-rpc-query-client.ts
          rpc-mutation-options.spec.ts
          rpc-mutation-options.ts
          rpc-query-helpers.spec.ts
          rpc-query-key.spec.ts
          rpc-query-key.ts
          rpc-query-options.spec.ts
          rpc-query-options.ts
          rpc-query-path.ts
          rpc-query-types.spec.ts
          rpc-query-types.ts
        testing/
          rpc-contracts.ts
        oss-community-files.spec.ts
        package.spec.ts
        public-api.spec.ts
        public-api.ts
        readme-examples.spec.ts
        readme.spec.ts
        root-readme.spec.ts
      ng-package.json
      package.json
      README.md
      tsconfig.lib.json
      tsconfig.lib.prod.json
      tsconfig.spec.json
    effect-platform-angular/
      src/
        lib/
          effect-http-client.ts
          effect-platform-angular.spec.ts
          effect-rpc-protocol-http-layer.spec.ts
          effect-rpc-protocol-http-layer.ts
          http-client-adapter.ts
        public-api.spec.ts
        public-api.ts
        rpc-example.spec.ts
      ng-package.json
      package.json
      README.md
      tsconfig.lib.json
      tsconfig.lib.prod.json
      tsconfig.spec.json
  .editorconfig
  .gitignore
  AGENTS.md
  angular.json
  CHANGELOG.md
  CHANGESETS.md
  CODE_OF_CONDUCT.md
  CONTRIBUTING.md
  git-town.toml
  knope.toml
  LICENSE
  package.json
  README.md
  release-smoke-test.md
  tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="effect-angular-effect-platform-angular-v0.0.7/.codex/config.toml">
[mcp_servers.playwright-test]
command = "npx"
args = ["playwright", "run-test-mcp-server"]

[mcp_servers.angular-cli]
command = "npx"
args = ["-y", "@angular/cli@latest", "mcp", "-E", "modernize"]

[mcp_servers.git-grep]
url = "https://mcp.grep.app"

[features]
unified_exec = true
shell_snapshot = true
collab = true
steer = true
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/.github/workflows/prepare_release_pr.yml">
name: Validate Release Readiness

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

jobs:
  validate-release-pr:
    if: "${{ github.event_name == 'workflow_dispatch' || github.head_ref == 'knope/release' }}"
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_PAT || secrets.GITHUB_TOKEN }}

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.2.19'

      - name: Install Knope
        uses: knope-dev/action@v2.1.0
        with:
          version: 0.22.2
          github-token: ${{ secrets.RELEASE_PAT || secrets.GITHUB_TOKEN }}

      - name: Validate Knope configuration
        run: knope --validate

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run tests
        run: CI=true bun run test -- --watch=false

      - name: Build packages
        run: |
          bun run ng build effect-platform-angular
          bun run ng build effect-angular-query

      - name: Pack effect-platform-angular (dry-run)
        working-directory: dist/effect-platform-angular
        run: npm pack --dry-run

      - name: Pack effect-angular-query (dry-run)
        working-directory: dist/effect-angular-query
        run: npm pack --dry-run
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/.github/workflows/release.yml">
name: Release

on:
  pull_request:
    types:
      - closed
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

jobs:
  release:
    if: "${{ (github.head_ref == 'knope/release' && github.event.pull_request.merged == true) || github.event_name == 'workflow_dispatch' }}"
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v5

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.2.19'

      - name: Set up Node for npm publish
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run tests
        run: CI=true bun run test -- --watch=false

      - name: Build packages
        run: |
          bun run ng build effect-platform-angular
          bun run ng build effect-angular-query

      - name: Check if effect-platform-angular version is unpublished
        id: check_effect_platform_angular
        working-directory: dist/effect-platform-angular
        run: |
          PACKAGE_NAME="$(node -p "require('./package.json').name")"
          PACKAGE_VERSION="$(node -p "require('./package.json').version")"
          if npm view "${PACKAGE_NAME}@${PACKAGE_VERSION}" version >/dev/null 2>&1; then
            echo "publish=false" >> "$GITHUB_OUTPUT"
            echo "${PACKAGE_NAME}@${PACKAGE_VERSION} is already published. Skipping publish."
          else
            echo "publish=true" >> "$GITHUB_OUTPUT"
            echo "${PACKAGE_NAME}@${PACKAGE_VERSION} is not published yet. Will publish."
          fi

      - name: Publish effect-platform-angular to npm
        if: steps.check_effect_platform_angular.outputs.publish == 'true'
        working-directory: dist/effect-platform-angular
        env:
          NODE_AUTH_TOKEN: ''
        run: npm publish

      - name: Check if effect-angular-query version is unpublished
        id: check_effect_angular_query
        working-directory: dist/effect-angular-query
        run: |
          PACKAGE_NAME="$(node -p "require('./package.json').name")"
          PACKAGE_VERSION="$(node -p "require('./package.json').version")"
          if npm view "${PACKAGE_NAME}@${PACKAGE_VERSION}" version >/dev/null 2>&1; then
            echo "publish=false" >> "$GITHUB_OUTPUT"
            echo "${PACKAGE_NAME}@${PACKAGE_VERSION} is already published. Skipping publish."
          else
            echo "publish=true" >> "$GITHUB_OUTPUT"
            echo "${PACKAGE_NAME}@${PACKAGE_VERSION} is not published yet. Will publish."
          fi

      - name: Publish effect-angular-query to npm
        if: steps.check_effect_angular_query.outputs.publish == 'true'
        working-directory: dist/effect-angular-query
        env:
          NODE_AUTH_TOKEN: ''
        run: npm publish
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/.vscode/extensions.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=827846
  "recommendations": ["angular.ng-template"]
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/.vscode/launch.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "name": "ng serve",
      "type": "chrome",
      "request": "launch",
      "preLaunchTask": "npm: start",
      "url": "http://localhost:4200/"
    },
    {
      "name": "ng test",
      "type": "chrome",
      "request": "launch",
      "preLaunchTask": "npm: test",
      "url": "http://localhost:9876/debug.html"
    }
  ]
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/.vscode/mcp.json">
{
  // For more information, visit: https://angular.dev/ai/mcp
  "servers": {
    "angular-cli": {
      "command": "npx",
      "args": ["-y", "@angular/cli", "mcp"]
    }
  }
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/.vscode/tasks.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?LinkId=733558
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "start",
      "isBackground": true,
      "problemMatcher": {
        "owner": "typescript",
        "pattern": "$tsc",
        "background": {
          "activeOnStart": true,
          "beginsPattern": {
            "regexp": "Changes detected"
          },
          "endsPattern": {
            "regexp": "bundle generation (complete|failed)"
          }
        }
      }
    },
    {
      "type": "npm",
      "script": "test",
      "isBackground": true,
      "problemMatcher": {
        "owner": "typescript",
        "pattern": "$tsc",
        "background": {
          "activeOnStart": true,
          "beginsPattern": {
            "regexp": "Changes detected"
          },
          "endsPattern": {
            "regexp": "bundle generation (complete|failed)"
          }
        }
      }
    }
  ]
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/effect_rpc_angular_query_helpers_20260130/index.md">
# Track effect_rpc_angular_query_helpers_20260130 Context

- [Specification](./spec.md)
- [Implementation Plan](./plan.md)
- [Metadata](./metadata.json)
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/effect_rpc_angular_query_helpers_20260130/metadata.json">
{
  "track_id": "effect_rpc_angular_query_helpers_20260130",
  "type": "feature",
  "status": "new",
  "created_at": "2026-01-30T13:41:34Z",
  "updated_at": "2026-01-30T13:41:34Z",
  "description": "Add an integration of an Effect RPC client with @tanstack/angular-query-experimental to generate query options for injectQuery from the RPC client config"
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/effect_rpc_angular_query_helpers_20260130/plan.md">
# Implementation Plan

## Phase 1: Core query key + options utilities [checkpoint: fb14a19]
- [x] Task: Review `injectQuery` expectations in `@tanstack/angular-query-experimental` and confirm the options shape (4923c25)
    - [x] Inspect types for `injectQuery` and `queryOptions` (if available)
    - [x] Define adapter types for query options and queryFn compatibility
- [x] Task: Implement query key helpers (path segments + input + optional keyPrefix) (b16bda6)
    - [x] Write failing tests for `queryKey` shape (path segments, input, keyPrefix)
    - [x] Implement query key builder and helper types
    - [x] Refactor/cleanup and rerun tests
- [x] Task: Implement query options factory (queryFn + metadata + overrides) (e785f29)
    - [x] Write failing tests for `queryOptions` output (queryKey, queryFn, metadata, override merge)
    - [x] Implement query options factory and `rpc` metadata attachment
    - [x] Refactor/cleanup and rerun tests
- [x] Task: Conductor - User Manual Verification 'Phase 1: Core query key + options utilities' (Protocol in workflow.md) (49b0ef6)

## Phase 2: Angular integration + typed helpers [checkpoint: 61b2348]
- [x] Task: Create Angular DI config and injectable helper service (c72c9e1)
    - [x] Write failing tests for DI setup and config defaults
    - [x] Implement tokens/config and injectable service
    - [x] Refactor/cleanup and rerun tests
- [x] Task: Build per-procedure helpers + path-level invalidation utilities (3247bbc)
    - [x] Write failing tests for per-procedure `queryKey`/`queryFn`/`queryOptions`
    - [x] Write failing tests for `pathKey`/`queryFilter` helpers
    - [x] Implement typed proxy helpers for procedures and path-level utilities
    - [x] Refactor/cleanup and rerun tests
- [x] Task: Replace placeholder component and update public API exports (d3a87b8)
    - [x] Write failing tests for new public API exports
    - [x] Remove placeholder component and export new APIs
    - [x] Refactor/cleanup and rerun tests
- [x] Task: Conductor - User Manual Verification 'Phase 2: Angular integration + typed helpers' (Protocol in workflow.md) (906548e)

## Phase 3: Packaging + docs [checkpoint: df9157f]
- [x] Task: Update package dependencies/peerDependencies for TanStack Angular Query (0d42e9e)
    - [x] Write failing test or validation for updated public API surface
    - [x] Update `package.json`/`ng-package.json` as needed and rerun tests
- [x] Task: Add README usage examples and API docs (eadd96b)
    - [x] Document minimal setup and `injectQuery` usage with overrides
    - [x] Document query key shape, keyPrefix option, and path helpers
- [x] Task: Conductor - User Manual Verification 'Phase 3: Packaging + docs' (Protocol in workflow.md) (686b8f9)
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/effect_rpc_angular_query_helpers_20260130/spec.md">
# Specification

## Overview
Build an Angular-native integration between the Effect RPC client and TanStack Query's `@tanstack/angular-query-experimental` package that provides helper APIs to generate the `queryKey`, `queryFn`, and `queryOptions` required by `injectQuery`, using defaults from the RPC client configuration. The integration should be minimal and focused on wrapping as little as possible, while still offering a simple setup for consumers.

## Functional Requirements
1. Provide an Angular-injectable helper service that exposes per-procedure helpers for:
   - `queryKey`
   - `queryFn`
   - `queryOptions` composed from client defaults
2. The helper service must be constructed from an Effect RPC client configuration and expose per-call overrides that merge with defaults.
3. Default `queryKey` shape must be structured as:
   - `[pathSegments, { input?, type? }]`
   - Optional `keyPrefix` support that prepends a namespace when configured.
4. The helpers must target `injectQuery` usage in `@tanstack/angular-query-experimental` and return options compatible with `injectQuery`.
5. Attach metadata on options (e.g., `rpc: { path }`) for traceability/debugging.
6. Provide path-level helpers (e.g., `pathKey`/`queryFilter`) to support invalidation across a route subtree.

## Non-Functional Requirements
- Minimal setup: no automatic TanStack Query client wiring; consumers handle their own Query client setup.
- Maintain Angular-native ergonomics (injectable service, idiomatic APIs).
- Strong typing for procedure inputs/outputs and query options.
- Must align with Angular 21+ and project TypeScript strictness.

## Acceptance Criteria
- Consumers can inject a service and call `<procedure>.queryOptions(input, overrides)` to get a fully-typed object usable with `injectQuery`.
- `queryKey` and `queryFn` are available per procedure and derived from the RPC client config.
- `queryKey` is structured by path segments and input and supports an optional `keyPrefix`.
- Options include attached `rpc` metadata with the procedure path.
- Path-level helpers (`pathKey`/`queryFilter`) are available for invalidating related queries.
- Overrides merge cleanly with client defaults for each call.
- No infinite query helpers are included in this track.

## Out of Scope
- Infinite query helpers and pagination helpers.
- Automatic TanStack Query client provisioning or global configuration.
- Mutations or subscriptions (only `injectQuery` helpers are in scope).
- Additional integrations beyond Effect RPC + TanStack Query angular-query-experimental.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/oss_project_infra_20260130/notes/knope-release-workflow.md">
# Knope Release Workflow Definition

Date: 2026-02-07

## Change-file Strategy

- Location: `.changeset/`
- Format: Markdown file using release headings such as `### Added`, `### Changed`, `### Fixed`.
- Expectations:
  - Every user-facing PR includes one new file in `.changeset/`.
  - Keep entries concise and user-facing.
  - Multiple entries can be grouped in a single file when needed.

## Release PR/Bot Flow

- Release branch: `knope/release`
- Primary trigger condition:
  - `main` contains new change files and a release run is initiated.
- Result:
  - Knope prepares version/changelog updates.
  - A release PR is created/updated from `knope/release` into `main`.
  - Merging the release PR publishes a GitHub release.

## GitHub Actions Trigger Conditions

- Manual release workflow: `workflow_dispatch`
  - Prepares release changes
  - Runs test/build checks
  - Creates GitHub release through `knope release`
- Bot release workflow: `pull_request` closed on `main`
  - Only runs when merged PR head branch is `knope/release`
  - Executes post-release validation/publishing tasks
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/oss_project_infra_20260130/notes/readme-context-audit.md">
# README Context Audit

Date: 2026-02-07

## Workspace and Packages
- Workspace root contains two library projects under `projects/`:
  - `projects/effect-platform-angular`
  - `projects/effect-angular-query`
- Root package metadata:
  - package: `effect-angular`
  - package manager: `bun@1.2.19`

## Tooling Commands
Validated from root `package.json` scripts:
- Install dependencies: `bun install`
- Start dev server: `bun run start` (Angular CLI serve)
- Build: `bun run build`
- Test: `bun run test`

## Key Runtime Dependencies
- `@effect/platform`
- `@angular/common`
- `@angular/core`
- `@angular/router`
- `effect`
- `rxjs`

## Key Dev Dependencies
- `@effect/rpc`
- `@tanstack/angular-query-experimental`
- `@angular/cli`
- `@angular/build`
- `ng-packagr`
- `vitest`
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/oss_project_infra_20260130/index.md">
# Track oss_project_infra_20260130 Context

- [Specification](./spec.md)
- [Implementation Plan](./plan.md)
- [Metadata](./metadata.json)
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/oss_project_infra_20260130/metadata.json">
{
  "track_id": "oss_project_infra_20260130",
  "type": "feature",
  "status": "archived",
  "created_at": "2026-01-30T14:01:00Z",
  "updated_at": "2026-02-07T17:13:51Z",
  "description": "Add a root README and Knope-based release tooling with GitHub Actions, plus Dependabot and core community files for OSS readiness."
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/oss_project_infra_20260130/plan.md">
# Plan: OSS project scaffolding + Knope release flow

## Phase 1: Documentation & Community Baseline
- [x] Task: Review existing repo context for README accuracy [29d0c77]
    - [x] Inspect root `package.json` and workspace layout for package list
    - [x] Confirm current install/dev/test commands from tooling
- [x] Task: Draft and add root README [8068283]
    - [x] Write overview and goals aligned with `conductor/product.md`
    - [x] Add quickstart/setup using Bun + Angular workspace
    - [x] Document key packages in the monorepo
- [x] Task: Add community/health files [9bb3ce4]
    - [x] Add MIT LICENSE
    - [x] Add CODE_OF_CONDUCT
    - [x] Add CONTRIBUTING
    - [x] Add SECURITY
- [~] Task: Conductor - User Manual Verification 'Phase 1: Documentation & Community Baseline' (Protocol in workflow.md)

## Phase 2: Knope Release Automation
- [x] Task: Define Knope release workflow for this repo [7a4c4fa]
    - [x] Capture change-file strategy (location, format, expectations)
    - [x] Map bot flow details (release PR branch, trigger conditions)
- [x] Task: Add Knope configuration [6a73e3e]
    - [x] Create Knope config files per bot workflow
    - [x] Configure change-file behavior and release rules
- [x] Task: Add GitHub Actions workflows for Knope bot flow [ad02cd8]
    - [x] Add workflow(s) required by Knope bot
    - [x] Ensure permissions and branch targets align with bot flow
- [x] Task: Validate automation setup [77ccd51]
    - [x] Sanity-check workflow YAML and config files
    - [x] Document expected release flow in README or CONTRIBUTING
- [~] Task: Conductor - User Manual Verification 'Phase 2: Knope Release Automation' (Protocol in workflow.md)

## Phase 3: Dependency Automation
- [ ] Task: Add Dependabot configuration
    - [ ] Define ecosystems (npm/bun) and update schedule
    - [ ] Set update policies for workspace layout
- [ ] Task: Validate Dependabot config
    - [ ] Verify file structure and paths are correct
- [ ] Task: Conductor - User Manual Verification 'Phase 3: Dependency Automation' (Protocol in workflow.md)
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/oss_project_infra_20260130/spec.md">
# Spec: Add OSS project scaffolding + Knope release flow

## Overview
Add foundational open-source project scaffolding and automation, including a root README, a Knope-based release flow aligned with the Knope GitHub Bot workflow (change files in PRs; release PRs generated by the bot), Dependabot configuration, and core community/health files.

## Functional Requirements
1. Root README
   - High-level project overview and goals
   - Quickstart/setup instructions aligned with current tooling (Bun, Angular workspace)
   - Pointers to key packages/libraries in this repo
2. Release automation
   - Knope configuration aligned with the Knope GitHub Bot workflow
   - Change files in PRs as the release input mechanism
   - GitHub Actions workflow(s) to support the bot-driven release PR flow
3. Dependabot
   - Automated dependency update configuration for the repository
4. Community/health files
   - LICENSE (MIT)
   - CODE_OF_CONDUCT
   - CONTRIBUTING
   - SECURITY

## Non-Functional Requirements
- Works with GitHub Actions
- Non-interactive CI execution
- Minimal additional tooling beyond Knope
- Clear, maintainable documentation
- Consistent with existing repo conventions

## Acceptance Criteria
- A new root `README.md` exists and includes overview + quickstart + package references
- Knope is configured for a change-file-driven, bot-based release workflow
- GitHub Actions workflows are present and aligned with the Knope bot flow
- Dependabot configuration is present and valid
- LICENSE, CODE_OF_CONDUCT, CONTRIBUTING, and SECURITY files are present
- License is MIT

## Out of Scope
- Additional governance/funding files (e.g., GOVERNANCE, MAINTAINERS, FUNDING)
- Issue/PR templates
- Large documentation site or multi-page docs
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/start_effect_platform_angular_httpclient_20260128/index.md">
# Track start_effect_platform_angular_httpclient_20260128 Context

- [Specification](./spec.md)
- [Implementation Plan](./plan.md)
- [Metadata](./metadata.json)
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/start_effect_platform_angular_httpclient_20260128/metadata.json">
{
  "track_id": "start_effect_platform_angular_httpclient_20260128",
  "type": "feature",
  "status": "new",
  "created_at": "2026-01-28T14:21:15Z",
  "updated_at": "2026-01-28T14:28:00Z",
  "description": "Start effect-platform-angular with HttpClient, including a minimal documented Effect RPC usage example"
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/start_effect_platform_angular_httpclient_20260128/plan.md">
# Implementation Plan

## Phase 1: Library Entry Points and DI [checkpoint: 1aeb891]
- [x] Task: Define the Angular provider API for the Effect HTTP client adapter (c7a9fc2)
    - [ ] Write failing tests for provider registration and injection via TestBed
    - [ ] Implement provider functions/tokens that bind Angular HttpClient to the Effect adapter
    - [ ] Update `public-api.ts` and remove the scaffolded component exports
- [x] Task: Conductor - User Manual Verification 'Phase 1: Library Entry Points and DI' (Protocol in workflow.md) (510c129)

## Phase 2: HttpClient Adapter Behavior [checkpoint: e58d18d]
- [x] Task: Map Effect HTTP requests to Angular HttpClient options (ddb6da3)
    - [ ] Write failing tests for method, headers, query params, and body mapping
    - [ ] Implement request translation logic using Angular HttpClient
- [x] Task: Map Angular HttpClient responses and errors to Effect HTTP response types (3cf504b)
    - [ ] Write failing tests for status, headers, body parsing, and error handling
    - [ ] Implement response conversion and error mapping
- [x] Task: Support cancellation and abort semantics (7811fc1)
    - [ ] Write failing tests that cancel an Effect request and assert HttpClient abort
    - [ ] Implement cancellation bridging for in-flight requests
- [x] Task: Add clarifying code comments for new adapter and tests (49f2b4c)
- [x] Task: Consolidate Effect Platform imports (unify @effect/platform entries) (46f1122)
- [x] Task: Conductor - User Manual Verification 'Phase 2: HttpClient Adapter Behavior' (Protocol in workflow.md) (e58d18d)

## Phase 3: Documentation and Readiness [checkpoint: ae3b9a9]
- [x] Task: Document Angular usage and minimal Effect RPC example (fbbd323)
    - [ ] Draft quickstart and concepts sections for the adapter
    - [ ] Add a minimal documented Effect RPC usage example for Angular apps
- [x] Task: Validate build and public API surface (2111f76)
    - [ ] Add or adjust tests that cover the exported API surface
    - [ ] Confirm the package builds cleanly with the new exports
- [x] Task: Add tests for the Effect RPC documentation example (fe4be95)
- [x] Task: Remove Node dependency from the RPC example test (0d3e5df)
- [x] Task: Refine RPC example DX with injectable service returning promises (f80c0a6)
- [x] Task: Use RpcClient procedures in the RPC example test (5ca78af)
- [x] Task: Simplify the RPC example test and expose a promise client directly (ca1088a)
- [x] Task: Simplify RPC example to expose promise procedures directly on the service (930382e)
- [x] Task: Conductor - User Manual Verification 'Phase 3: Documentation and Readiness' (Protocol in workflow.md) (befdcc1)
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/archive/start_effect_platform_angular_httpclient_20260128/spec.md">
# Track Specification: Start effect-platform-angular with HttpClient, including a minimal documented Effect RPC usage example

## Context
The goal is to establish the `effect-platform-angular` package as the Angular-native HTTP client integration for Effect Platform. It should build on Angular's `HttpClient`, follow Angular conventions, and align with the API patterns in `effect-platform-browser`. This integration is the foundation for using Effect RPC in Angular applications, with a minimal documented example to validate the intended usage.

## Goals
- Provide a DI-friendly, Angular-idiomatic entry point for Effect Platform HTTP client usage.
- Map Effect Platform HTTP requests to Angular `HttpClient` calls with strong typing.
- Align API naming and behavior with `effect-platform-browser` where it fits Angular norms.
- Keep the setup minimal so Angular apps can adopt it with little boilerplate.

## Non-goals
- Additional integrations beyond the HTTP client adapter.
- Advanced caching or persistence features beyond Angular defaults.
- Dedicated SSR-specific optimizations.

## Requirements
### Functional
- Provide Angular providers and tokens to register the Effect HTTP client adapter.
- Translate request method, headers, query params, and body from Effect request types to `HttpClient` options.
- Convert `HttpClient` responses and errors to Effect HTTP response types consistently.
- Support request cancellation/abort semantics compatible with Effect.

### Documentation
- Add a quickstart and concepts section for using the adapter in Angular apps.
- Include a minimal documented Effect RPC usage example showing the intended path in Angular.

### Quality
- Unit tests cover request mapping, response mapping, and cancellation behavior.
- Type safety is preserved across all public APIs.

## Deliverables
- Updated `effect-platform-angular` library code and public API exports.
- Unit tests for the adapter behavior.
- Documentation updates for Angular usage.

## Acceptance Criteria
- `effect-platform-angular` builds successfully and exports the intended provider API.
- Tests verify request/response translation and cancellation behavior.
- Documentation demonstrates how Angular apps can use the adapter as the HTTP client foundation for Effect RPC, with a minimal example.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/code_styleguides/general.md">
# General Code Style Principles

This document outlines general coding principles that apply across all languages and frameworks used in this project.

## Readability
- Code should be easy to read and understand by humans.
- Avoid overly clever or obscure constructs.

## Consistency
- Follow existing patterns in the codebase.
- Maintain consistent formatting, naming, and structure.

## Simplicity
- Prefer simple solutions over complex ones.
- Break down complex problems into smaller, manageable parts.

## Maintainability
- Write code that is easy to modify and extend.
- Minimize dependencies and coupling.

## Documentation
- Document *why* something is done, not just *what*.
- Keep documentation up-to-date with code changes.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/code_styleguides/html-css.md">
# Google HTML/CSS Style Guide Summary

This document summarizes key rules and best practices from the Google HTML/CSS Style Guide.

## 1. General Rules
- **Protocol:** Use HTTPS for all embedded resources.
- **Indentation:** Indent by 2 spaces. Do not use tabs.
- **Capitalization:** Use only lowercase for all code (element names, attributes, selectors, properties).
- **Trailing Whitespace:** Remove all trailing whitespace.
- **Encoding:** Use UTF-8 (without a BOM). Specify `<meta charset="utf-8">` in HTML.

## 2. HTML Style Rules
- **Document Type:** Use `<!doctype html>`.
- **HTML Validity:** Use valid HTML.
- **Semantics:** Use HTML elements according to their intended purpose (e.g., use `<p>` for paragraphs, not for spacing).
- **Multimedia Fallback:** Provide `alt` text for images and transcripts/captions for audio/video.
- **Separation of Concerns:** Strictly separate structure (HTML), presentation (CSS), and behavior (JavaScript). Link to CSS and JS from external files.
- **`type` Attributes:** Omit `type` attributes for stylesheets (`<link>`) and scripts (`<script>`).

## 3. HTML Formatting Rules
- **General:** Use a new line for every block, list, or table element, and indent its children.
- **Quotation Marks:** Use double quotation marks (`""`) for attribute values.

## 4. CSS Style Rules
- **CSS Validity:** Use valid CSS.
- **Class Naming:** Use meaningful, generic names. Separate words with a hyphen (`-`).
  - **Good:** `.video-player`, `.site-navigation`
  - **Bad:** `.vid`, `.red-text`
- **ID Selectors:** Avoid using ID selectors for styling. Prefer class selectors.
- **Shorthand Properties:** Use shorthand properties where possible (e.g., `padding`, `font`).
- **`0` and Units:** Omit units for `0` values (e.g., `margin: 0;`).
- **Leading `0`s:** Always include leading `0`s for decimal values (e.g., `font-size: 0.8em;`).
- **Hexadecimal Notation:** Use 3-character hex notation where possible (e.g., `#fff`).
- **`!important`:** Avoid using `!important`.

## 5. CSS Formatting Rules
- **Declaration Order:** Alphabetize declarations within a rule.
- **Indentation:** Indent all block content.
- **Semicolons:** Use a semicolon after every declaration.
- **Spacing:**
  - Use a space after a property name's colon (`font-weight: bold;`).
  - Use a space between the last selector and the opening brace (`.foo {`).
  - Start a new line for each selector and declaration.
- **Rule Separation:** Separate rules with a new line.
- **Quotation Marks:** Use single quotes (`''`) for attribute selectors and property values (e.g., `[type='text']`).

**BE CONSISTENT.** When editing code, match the existing style.

*Source: [Google HTML/CSS Style Guide](https://google.github.io/styleguide/htmlcssguide.html)*
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/code_styleguides/typescript.md">
# Google TypeScript Style Guide Summary

This document summarizes key rules and best practices from the Google TypeScript Style Guide, which is enforced by the `gts` tool.

## 1. Language Features
- **Variable Declarations:** Always use `const` or `let`. **`var` is forbidden.** Use `const` by default.
- **Modules:** Use ES6 modules (`import`/`export`). **Do not use `namespace`.**
- **Exports:** Use named exports (`export {MyClass};`). **Do not use default exports.**
- **Classes:**
  - **Do not use `#private` fields.** Use TypeScript's `private` visibility modifier.
  - Mark properties never reassigned outside the constructor with `readonly`.
  - **Never use the `public` modifier** (it's the default). Restrict visibility with `private` or `protected` where possible.
- **Functions:** Prefer function declarations for named functions. Use arrow functions for anonymous functions/callbacks.
- **String Literals:** Use single quotes (`'`). Use template literals (`` ` ``) for interpolation and multi-line strings.
- **Equality Checks:** Always use triple equals (`===`) and not equals (`!==`).
- **Type Assertions:** **Avoid type assertions (`x as SomeType`) and non-nullability assertions (`y!`)**. If you must use them, provide a clear justification.

## 2. Disallowed Features
- **`any` Type:** **Avoid `any`**. Prefer `unknown` or a more specific type.
- **Wrapper Objects:** Do not instantiate `String`, `Boolean`, or `Number` wrapper classes.
- **Automatic Semicolon Insertion (ASI):** Do not rely on it. **Explicitly end all statements with a semicolon.**
- **`const enum`:** Do not use `const enum`. Use plain `enum` instead.
- **`eval()` and `Function(...string)`:** Forbidden.

## 3. Naming
- **`UpperCamelCase`:** For classes, interfaces, types, enums, and decorators.
- **`lowerCamelCase`:** For variables, parameters, functions, methods, and properties.
- **`CONSTANT_CASE`:** For global constant values, including enum values.
- **`_` Prefix/Suffix:** **Do not use `_` as a prefix or suffix** for identifiers, including for private properties.

## 4. Type System
- **Type Inference:** Rely on type inference for simple, obvious types. Be explicit for complex types.
- **`undefined` and `null`:** Both are supported. Be consistent within your project.
- **Optional vs. `|undefined`:** Prefer optional parameters and fields (`?`) over adding `|undefined` to the type.
- **`Array<T>` Type:** Use `T[]` for simple types. Use `Array<T>` for more complex union types (e.g., `Array<string | number>`).
- **`{}` Type:** **Do not use `{}`**. Prefer `unknown`, `Record<string, unknown>`, or `object`.

## 5. Comments and Documentation
- **JSDoc:** Use `/** JSDoc */` for documentation, `//` for implementation comments.
- **Redundancy:** **Do not declare types in `@param` or `@return` blocks** (e.g., `/** @param {string} user */`). This is redundant in TypeScript.
- **Add Information:** Comments must add information, not just restate the code.

*Source: [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html)*
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/index.md">
# Project Context

## Definition
- [Product Definition](./product.md)
- [Product Guidelines](./product-guidelines.md)
- [Tech Stack](./tech-stack.md)

## Workflow
- [Workflow](./workflow.md)
- [Code Style Guides](./code_styleguides/)

## Management
- [Tracks Registry](./tracks.md)
- [Tracks Directory](./tracks/)
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/product-guidelines.md">
# Product Guidelines

## Documentation Voice and Tone
- Concise, technical, and reference-oriented.
- Friendly and teaching-oriented, with guided examples.

## Documentation Structure
- Quickstart for fast onboarding.
- Concepts section for core mental models.
- API reference for complete, authoritative details.

## API Design Principles
- Angular-idiomatic APIs (DI-first, provideX/functional setup, signal-friendly patterns).
- Layered API surface: simple Angular-first defaults with advanced escape hatches.

## Stability and Release Policy
- Strict SemVer.
- Deprecate before breaking changes and provide migration guides.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/product.md">
# Product Definition

## Overview
Effect Angular provides Angular libraries that integrate Effect Platform and Effect RPC with Angular. The initial focus is two integrations:
1) An Effect-based HTTP client built on Angular HttpClient.
2) An Effect RPC client integrated with TanStack Query for Angular.

## Audience
Open-source Angular developers who want Effect-first integrations.

## Goals
- Native Angular feel in APIs and usage patterns (prioritize Angular conventions over React-inspired patterns).
- Minimal connection and boilerplate; closely follow existing integrations where they align with Angular norms.
- Strong type safety with Effect-first semantics.
- Interoperability with Angular HttpClient and TanStack Query defaults.

## Scope (v1)
- Effect Platform HTTP client integration using Angular HttpClient.
- Effect RPC client integration with TanStack Query for Angular.
- Typed library APIs with minimal usage examples.
- Documentation: quickstart and integration guides.
- Tests that verify expected behavior.

## Non-goals (v1)
- Additional integrations beyond the two above.
- Advanced caching or persistence beyond TanStack defaults.
- Dedicated SSR optimizations; rely on Angular HttpClient behavior.

## Compatibility
- Angular 21+.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/setup_state.json">
{"last_successful_step": "3.3_initial_track_generated"}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/tech-stack.md">
# Tech Stack

## Languages
- TypeScript (strict mode enabled).

## Frameworks and Core Libraries
- Angular 21 (standalone components default, strict templates).
- RxJS 7.8.

## Project Type
- Angular workspace with library projects:
  - `effect-platform-angular`
  - `effect-angular-query`

## Build and Packaging
- Angular CLI / @angular/build.
- ng-packagr for library packaging.

## Testing
- Vitest (via Angular unit-test builder).

## Tooling
- TypeScript 5.9.
- Bun 1.2.x as the package manager.

## Data/Storage
- No database or driver detected.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/tracks.md">
# Project Tracks

This file tracks all major tracks for the project. Each track has its own detailed plan in its respective folder.

---

<!-- archived: conductor/archive/start_effect_platform_angular_httpclient_20260128 -->
<!-- archived: conductor/archive/oss_project_infra_20260130 -->

---
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/conductor/workflow.md">
# Project Workflow

## Guiding Principles

1. **The Plan is the Source of Truth:** All work must be tracked in `plan.md`
2. **The Tech Stack is Deliberate:** Changes to the tech stack must be documented in `tech-stack.md` *before* implementation
3. **Test-Driven Development:** Write unit tests before implementing functionality
4. **High Code Coverage:** Aim for >80% code coverage for all modules
5. **User Experience First:** Every decision should prioritize user experience
6. **Non-Interactive & CI-Aware:** Prefer non-interactive commands. Use `CI=true` for watch-mode tools (tests, linters) to ensure single execution.

## Task Workflow

All tasks follow a strict lifecycle:

### Standard Task Workflow

1. **Select Task:** Choose the next available task from `plan.md` in sequential order

2. **Mark In Progress:** Before beginning work, edit `plan.md` and change the task from `[ ]` to `[~]`

3. **Write Failing Tests (Red Phase):**
   - Create a new test file for the feature or bug fix.
   - Write one or more unit tests that clearly define the expected behavior and acceptance criteria for the task.
   - **CRITICAL:** Run the tests and confirm that they fail as expected. This is the "Red" phase of TDD. Do not proceed until you have failing tests.

4. **Implement to Pass Tests (Green Phase):**
   - Write the minimum amount of application code necessary to make the failing tests pass.
   - Run the test suite again and confirm that all tests now pass. This is the "Green" phase.

5. **Refactor (Optional but Recommended):**
   - With the safety of passing tests, refactor the implementation code and the test code to improve clarity, remove duplication, and enhance performance without changing the external behavior.
   - Rerun tests to ensure they still pass after refactoring.

6. **Verify Coverage:** Run coverage reports using the project's chosen tools. For example, in a Python project, this might look like:
   ```bash
   pytest --cov=app --cov-report=html
   ```
   Target: >80% coverage for new code. The specific tools and commands will vary by language and framework.

7. **Document Deviations:** If implementation differs from tech stack:
   - **STOP** implementation
   - Update `tech-stack.md` with new design
   - Add dated note explaining the change
   - Resume implementation

8. **Commit Code Changes:**
   - Stage all code changes related to the task.
   - Propose a clear, concise commit message e.g, `feat(ui): Create basic HTML structure for calculator`.
   - Perform the commit.

9. **Attach Task Summary with Git Notes:**
   - **Step 9.1: Get Commit Hash:** Obtain the hash of the *just-completed commit* (`git log -1 --format="%H"`).
   - **Step 9.2: Draft Note Content:** Create a detailed summary for the completed task. This should include the task name, a summary of changes, a list of all created/modified files, and the core "why" for the change.
   - **Step 9.3: Attach Note:** Use the `git notes` command to attach the summary to the commit.
     ```bash
     # The note content from the previous step is passed via the -m flag.
     git notes add -m "<note content>" <commit_hash>
     ```

10. **Get and Record Task Commit SHA:**
    - **Step 10.1: Update Plan:** Read `plan.md`, find the line for the completed task, update its status from `[~]` to `[x]`, and append the first 7 characters of the *just-completed commit's* commit hash.
    - **Step 10.2: Write Plan:** Write the updated content back to `plan.md`.

11. **Commit Plan Update:**
    - **Action:** Stage the modified `plan.md` file.
    - **Action:** Commit this change with a descriptive message (e.g., `conductor(plan): Mark task 'Create user model' as complete`).

### Phase Completion Verification and Checkpointing Protocol

**Trigger:** This protocol is executed immediately after a task is completed that also concludes a phase in `plan.md`.

1.  **Announce Protocol Start:** Inform the user that the phase is complete and the verification and checkpointing protocol has begun.

2.  **Ensure Test Coverage for Phase Changes:**
    -   **Step 2.1: Determine Phase Scope:** To identify the files changed in this phase, you must first find the starting point. Read `plan.md` to find the Git commit SHA of the *previous* phase's checkpoint. If no previous checkpoint exists, the scope is all changes since the first commit.
    -   **Step 2.2: List Changed Files:** Execute `git diff --name-only <previous_checkpoint_sha> HEAD` to get a precise list of all files modified during this phase.
    -   **Step 2.3: Verify and Create Tests:** For each file in the list:
        -   **CRITICAL:** First, check its extension. Exclude non-code files (e.g., `.json`, `.md`, `.yaml`).
        -   For each remaining code file, verify a corresponding test file exists.
        -   If a test file is missing, you **must** create one. Before writing the test, **first, analyze other test files in the repository to determine the correct naming convention and testing style.** The new tests **must** validate the functionality described in this phase's tasks (`plan.md`).

3.  **Execute Automated Tests with Proactive Debugging:**
    -   Before execution, you **must** announce the exact shell command you will use to run the tests.
    -   **Example Announcement:** "I will now run the automated test suite to verify the phase. **Command:** `CI=true npm test`"
    -   Execute the announced command.
    -   If tests fail, you **must** inform the user and begin debugging. You may attempt to propose a fix a **maximum of two times**. If the tests still fail after your second proposed fix, you **must stop**, report the persistent failure, and ask the user for guidance.

4.  **Propose a Detailed, Actionable Manual Verification Plan:**
    -   **CRITICAL:** To generate the plan, first analyze `product.md`, `product-guidelines.md`, and `plan.md` to determine the user-facing goals of the completed phase.
    -   You **must** generate a step-by-step plan that walks the user through the verification process, including any necessary commands and specific, expected outcomes.
    -   The plan you present to the user **must** follow this format:

        **For a Frontend Change:**
        ```
        The automated tests have passed. For manual verification, please follow these steps:

        **Manual Verification Steps:**
        1.  **Start the development server with the command:** `npm run dev`
        2.  **Open your browser to:** `http://localhost:3000`
        3.  **Confirm that you see:** The new user profile page, with the user's name and email displayed correctly.
        ```

        **For a Backend Change:**
        ```
        The automated tests have passed. For manual verification, please follow these steps:

        **Manual Verification Steps:**
        1.  **Ensure the server is running.**
        2.  **Execute the following command in your terminal:** `curl -X POST http://localhost:8080/api/v1/users -d '{"name": "test"}'`
        3.  **Confirm that you receive:** A JSON response with a status of `201 Created`.
        ```

5.  **Await Explicit User Feedback:**
    -   After presenting the detailed plan, ask the user for confirmation: "**Does this meet your expectations? Please confirm with yes or provide feedback on what needs to be changed.**"
    -   **PAUSE** and await the user's response. Do not proceed without an explicit yes or confirmation.

6.  **Create Checkpoint Commit:**
    -   Stage all changes. If no changes occurred in this step, proceed with an empty commit.
    -   Perform the commit with a clear and concise message (e.g., `conductor(checkpoint): Checkpoint end of Phase X`).

7.  **Attach Auditable Verification Report using Git Notes:**
    -   **Step 7.1: Draft Note Content:** Create a detailed verification report including the automated test command, the manual verification steps, and the user's confirmation.
    -   **Step 7.2: Attach Note:** Use the `git notes` command and the full commit hash from the previous step to attach the full report to the checkpoint commit.

8.  **Get and Record Phase Checkpoint SHA:**
    -   **Step 8.1: Get Commit Hash:** Obtain the hash of the *just-created checkpoint commit* (`git log -1 --format="%H"`).
    -   **Step 8.2: Update Plan:** Read `plan.md`, find the heading for the completed phase, and append the first 7 characters of the commit hash in the format `[checkpoint: <sha>]`.
    -   **Step 8.3: Write Plan:** Write the updated content back to `plan.md`.

9. **Commit Plan Update:**
    - **Action:** Stage the modified `plan.md` file.
    - **Action:** Commit this change with a descriptive message following the format `conductor(plan): Mark phase '<PHASE NAME>' as complete`.

10.  **Announce Completion:** Inform the user that the phase is complete and the checkpoint has been created, with the detailed verification report attached as a git note.

### Quality Gates

Before marking any task complete, verify:

- [ ] All tests pass
- [ ] Code coverage meets requirements (>80%)
- [ ] Code follows project's code style guidelines (as defined in `code_styleguides/`)
- [ ] All public functions/methods are documented (e.g., docstrings, JSDoc, GoDoc)
- [ ] Type safety is enforced (e.g., type hints, TypeScript types, Go types)
- [ ] No linting or static analysis errors (using the project's configured tools)
- [ ] Works correctly on mobile (if applicable)
- [ ] Documentation updated if needed
- [ ] No security vulnerabilities introduced

## Development Commands

**AI AGENT INSTRUCTION: This section should be adapted to the project's specific language, framework, and build tools.**

### Setup
```bash
# Install dependencies
bun install
```

### Daily Development
```bash
# Common tasks
bun run start
bun run build
bun run test
```

### Before Committing
```bash
# Run tests and build artifacts
bun run test
bun run build
```

## Testing Requirements

### Unit Testing
- Every module must have corresponding tests.
- Use appropriate test setup/teardown mechanisms (e.g., fixtures, beforeEach/afterEach).
- Mock external dependencies.
- Test both success and failure cases.

### Integration Testing
- Test complete user flows
- Verify database transactions
- Test authentication and authorization
- Check form submissions

### Mobile Testing
- Test on actual iPhone when possible
- Use Safari developer tools
- Test touch interactions
- Verify responsive layouts
- Check performance on 3G/4G

## Code Review Process

### Self-Review Checklist
Before requesting review:

1. **Functionality**
   - Feature works as specified
   - Edge cases handled
   - Error messages are user-friendly

2. **Code Quality**
   - Follows style guide
   - DRY principle applied
   - Clear variable/function names
   - Appropriate comments

3. **Testing**
   - Unit tests comprehensive
   - Integration tests pass
   - Coverage adequate (>80%)

4. **Security**
   - No hardcoded secrets
   - Input validation present
   - SQL injection prevented
   - XSS protection in place

5. **Performance**
   - Database queries optimized
   - Images optimized
   - Caching implemented where needed

6. **Mobile Experience**
   - Touch targets adequate (44x44px)
   - Text readable without zooming
   - Performance acceptable on mobile
   - Interactions feel native

## Commit Guidelines

### Message Format
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

### Types
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation only
- `style`: Formatting, missing semicolons, etc.
- `refactor`: Code change that neither fixes a bug nor adds a feature
- `test`: Adding missing tests
- `chore`: Maintenance tasks

### Examples
```bash
git commit -m "feat(auth): Add remember me functionality"
git commit -m "fix(posts): Correct excerpt generation for short posts"
git commit -m "test(comments): Add tests for emoji reaction limits"
git commit -m "style(mobile): Improve button touch targets"
```

## Definition of Done

A task is complete when:

1. All code implemented to specification
2. Unit tests written and passing
3. Code coverage meets project requirements
4. Documentation complete (if applicable)
5. Code passes all configured linting and static analysis checks
6. Works beautifully on mobile (if applicable)
7. Implementation notes added to `plan.md`
8. Changes committed with proper message
9. Git note with task summary attached to the commit

## Emergency Procedures

### Critical Bug in Production
1. Create hotfix branch from main
2. Write failing test for bug
3. Implement minimal fix
4. Test thoroughly including mobile
5. Deploy immediately
6. Document in plan.md

### Data Loss
1. Stop all write operations
2. Restore from latest backup
3. Verify data integrity
4. Document incident
5. Update backup procedures

### Security Breach
1. Rotate all secrets immediately
2. Review access logs
3. Patch vulnerability
4. Notify affected users (if any)
5. Document and update security procedures

## Deployment Workflow

### Pre-Deployment Checklist
- [ ] All tests passing
- [ ] Coverage >80%
- [ ] No linting errors
- [ ] Mobile testing complete
- [ ] Environment variables configured
- [ ] Database migrations ready
- [ ] Backup created

### Deployment Steps
1. Merge feature branch to main
2. Tag release with version
3. Push to deployment service
4. Run database migrations
5. Verify deployment
6. Test critical paths
7. Monitor for errors

### Post-Deployment
1. Monitor analytics
2. Check error logs
3. Gather user feedback
4. Plan next iteration

## Continuous Improvement

- Review workflow weekly
- Update based on pain points
- Document lessons learned
- Optimize for user happiness
- Keep things simple and maintainable
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/effect-rpc-query-client.spec.ts">
import { TestBed } from '@angular/core/testing';
import { Rpc, RpcClient, RpcGroup } from '@effect/rpc';
import * as Effect from 'effect/Effect';
import * as Layer from 'effect/Layer';
import * as Schema from 'effect/Schema';

import {
  asRpcMutation,
  createEffectRpcAngularClient,
  createEffectRpcAngularClientConfig,
} from './effect-rpc-query-client';

const Ping = Rpc.make('Ping', {
  payload: Schema.Struct({ id: Schema.String }),
  success: Schema.Struct({ name: Schema.String }),
});
const Save = Rpc.make('save', {
  payload: Schema.Struct({ id: Schema.String, name: Schema.String }),
  success: Schema.Struct({ ok: Schema.Boolean }),
});

class AppRpcs extends RpcGroup.make(Ping, asRpcMutation(Save)) {}

const createRpcLayer = () =>
  Layer.effect(
    RpcClient.Protocol,
    RpcClient.Protocol.make(() =>
      Effect.succeed({
        send: () => Effect.succeed(undefined),
        supportsAck: false,
        supportsTransferables: false,
      }),
    ),
  );

describe('Effect RPC Angular client DI', () => {
  it('fills config defaults when omitted', () => {
    const config = createEffectRpcAngularClientConfig({
      group: AppRpcs,
      rpcLayer: createRpcLayer(),
    });

    expect(config.queryDefaults).toEqual({});
    expect(config.mutationDefaults).toEqual({});
  });

  it('creates providers and injectClient for a typed singleton', () => {
    const rpcClient = createEffectRpcAngularClient({
      group: AppRpcs,
      rpcLayer: createRpcLayer(),
      keyPrefix: 'app',
      queryDefaults: { staleTime: 5000 },
      mutationDefaults: { retry: 1 },
    });

    TestBed.configureTestingModule({
      providers: [rpcClient.providers],
    });

    const first = TestBed.runInInjectionContext(() => rpcClient.injectClient());
    const second = TestBed.runInInjectionContext(() => rpcClient.injectClient());

    expect(first).toBe(second);
    expect(first.Ping.queryKey({ id: '1' })).toEqual([
      ['app', 'Ping'],
      { input: { id: '1' }, type: 'query' },
    ]);
    expect(first.save.mutationKey()).toEqual([['app', 'save'], { type: 'mutation' }]);
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/effect-rpc-query-client.ts">
import {
  EnvironmentProviders,
  InjectionToken,
  inject,
  makeEnvironmentProviders,
} from '@angular/core';
import type {
  CreateMutationOptions,
  CreateQueryOptions,
  DefaultError,
  QueryFilters,
} from '@tanstack/angular-query-experimental';
import type * as Rpc from '@effect/rpc/Rpc';
import * as RpcClient from '@effect/rpc/RpcClient';
import type * as RpcClientError from '@effect/rpc/RpcClientError';
import type * as RpcGroup from '@effect/rpc/RpcGroup';
import * as RpcSchema from '@effect/rpc/RpcSchema';
import * as Context from 'effect/Context';
import * as Effect from 'effect/Effect';
import type * as Layer from 'effect/Layer';
import * as Option from 'effect/Option';

import { createRpcMutationOptions } from './rpc-mutation-options';
import type { RpcMutationOptionsOverrides } from './rpc-mutation-options';
import { createRpcQueryKey } from './rpc-query-key';
import type { RpcKeyPrefix } from './rpc-query-key';
import { createRpcQueryOptions } from './rpc-query-options';
import type { RpcQueryOptionsOverrides } from './rpc-query-options';
import { createRpcPathKey, createRpcQueryFilter } from './rpc-query-path';
import type { RpcPathKey, RpcPathOptions, RpcQueryFilterOptions } from './rpc-query-path';
import type {
  RpcMutationFn,
  RpcMutationKey,
  RpcQueryFn,
  RpcQueryKey,
  RpcQueryKeyType,
} from './rpc-query-types';

export type RpcProcedureKind = 'query' | 'mutation';

const RPC_PROCEDURE_KIND_ANNOTATION = Context.GenericTag<{ readonly kind: RpcProcedureKind }>(
  'effect-angular/RpcProcedureKind',
);

declare const RPC_PROCEDURE_KIND_BRAND: unique symbol;

type RpcProcedureBrand<Kind extends RpcProcedureKind> = {
  readonly [RPC_PROCEDURE_KIND_BRAND]?: Kind;
};

type RpcMarkable = Rpc.Any &
  Rpc.AnyWithProps & {
    readonly annotate: <Identifier, Service>(
      tag: Context.Tag<Identifier, Service>,
      value: Service,
    ) => unknown;
  };

export type RpcQueryProcedure<Current extends Rpc.Any> = Current & RpcProcedureBrand<'query'>;
export type RpcMutationProcedure<Current extends Rpc.Any> = Current & RpcProcedureBrand<'mutation'>;

type RpcProcedureKindOf<Current extends Rpc.Any> =
  Current extends RpcProcedureBrand<infer Kind> ? Kind : 'query';

export const asRpcQuery = <Current extends RpcMarkable>(rpc: Current): RpcQueryProcedure<Current> =>
  rpc.annotate(RPC_PROCEDURE_KIND_ANNOTATION, {
    kind: 'query',
  } as const) as RpcQueryProcedure<Current>;

export const asRpcMutation = <Current extends RpcMarkable>(
  rpc: Current,
): RpcMutationProcedure<Current> =>
  rpc.annotate(RPC_PROCEDURE_KIND_ANNOTATION, {
    kind: 'mutation',
  } as const) as RpcMutationProcedure<Current>;

export type EffectRpcAngularClientQueryDefaults = RpcQueryOptionsOverrides<
  unknown,
  DefaultError,
  unknown,
  RpcQueryKey<unknown>
>;

export type EffectRpcAngularClientMutationDefaults = RpcMutationOptionsOverrides<
  unknown,
  DefaultError,
  unknown,
  unknown
>;

export type EffectRpcAngularClientConfigInput<Rpcs extends Rpc.Any> = {
  readonly group: RpcGroup.RpcGroup<Rpcs>;
  readonly rpcLayer: Layer.Layer<RpcClient.Protocol, never, never>;
  readonly keyPrefix?: RpcKeyPrefix;
  readonly queryDefaults?: EffectRpcAngularClientQueryDefaults;
  readonly mutationDefaults?: EffectRpcAngularClientMutationDefaults;
};

export type EffectRpcAngularClientConfig<Rpcs extends Rpc.Any> = {
  readonly group: RpcGroup.RpcGroup<Rpcs>;
  readonly rpcLayer: Layer.Layer<RpcClient.Protocol, never, never>;
  readonly keyPrefix?: RpcKeyPrefix;
  readonly queryDefaults: EffectRpcAngularClientQueryDefaults;
  readonly mutationDefaults: EffectRpcAngularClientMutationDefaults;
};

export const createEffectRpcAngularClientConfig = <Rpcs extends Rpc.Any>(
  config: EffectRpcAngularClientConfigInput<Rpcs>,
): EffectRpcAngularClientConfig<Rpcs> => ({
  ...config,
  queryDefaults: config.queryDefaults ?? {},
  mutationDefaults: config.mutationDefaults ?? {},
});

type RpcTag<Rpcs extends Rpc.Any> = Rpc.Tag<Rpcs>;

type RpcPrefix<Tag extends string> = Tag extends `${infer Prefix}.${string}` ? Prefix : never;

type RpcPrefixes<Rpcs extends Rpc.Any> = RpcPrefix<RpcTag<Rpcs>>;

type RpcPrefixed<Rpcs extends Rpc.Any, Prefix extends string> = Extract<
  Rpcs,
  { readonly _tag: `${Prefix}.${string}` }
>;

type RpcNonPrefixed<Rpcs extends Rpc.Any> = Exclude<Rpcs, { readonly _tag: `${string}.${string}` }>;

export type RpcProcedureError<Current extends Rpc.Any> =
  | Rpc.ErrorExit<Current>
  | RpcClientError.RpcClientError;

export type RpcQueryKeyOverrides = {
  readonly keyPrefix?: RpcKeyPrefix;
};

export type RpcQueryOptionsInput<TInput, TQueryFnData, TError, TData> = {
  readonly overrides?: RpcQueryOptionsOverrides<TQueryFnData, TError, TData, RpcQueryKey<TInput>>;
  readonly keyPrefix?: RpcKeyPrefix;
};

export type RpcMutationKeyOverrides = {
  readonly keyPrefix?: RpcKeyPrefix;
};

export type RpcMutationOptionsInput<TQueryFnData, TError, TVariables, TOnMutateResult> = {
  readonly overrides?: RpcMutationOptionsOverrides<
    TQueryFnData,
    TError,
    TVariables,
    TOnMutateResult
  >;
  readonly keyPrefix?: RpcKeyPrefix;
};

type RpcProcedureBaseHelper<Current extends Rpc.Any> = {
  readonly call: (input: Rpc.PayloadConstructor<Current>) => Promise<Rpc.SuccessExit<Current>>;
  readonly callEffect: (
    input: Rpc.PayloadConstructor<Current>,
  ) => Effect.Effect<Rpc.SuccessExit<Current>, RpcProcedureError<Current>, never>;
};

type RpcQueryProcedureHelper<Current extends Rpc.Any> = RpcProcedureBaseHelper<Current> & {
  readonly queryKey: (
    input: Rpc.PayloadConstructor<Current>,
    options?: RpcQueryKeyOverrides,
  ) => RpcQueryKey<Rpc.PayloadConstructor<Current>>;
  readonly queryFn: (
    input: Rpc.PayloadConstructor<Current>,
  ) => RpcQueryFn<Rpc.SuccessExit<Current>, RpcQueryKey<Rpc.PayloadConstructor<Current>>>;
  readonly queryOptions: (
    input: Rpc.PayloadConstructor<Current>,
    options?: RpcQueryOptionsInput<
      Rpc.PayloadConstructor<Current>,
      Rpc.SuccessExit<Current>,
      RpcProcedureError<Current>,
      Rpc.SuccessExit<Current>
    >,
  ) => CreateQueryOptions<
    Rpc.SuccessExit<Current>,
    RpcProcedureError<Current>,
    Rpc.SuccessExit<Current>,
    RpcQueryKey<Rpc.PayloadConstructor<Current>>
  >;
};

type RpcMutationProcedureHelper<Current extends Rpc.Any> = RpcProcedureBaseHelper<Current> & {
  readonly mutationKey: (options?: RpcMutationKeyOverrides) => RpcMutationKey;
  readonly mutationFn: () => RpcMutationFn<
    Rpc.SuccessExit<Current>,
    Rpc.PayloadConstructor<Current>,
    RpcProcedureError<Current>,
    unknown
  >;
  readonly mutationOptions: <TOnMutateResult = unknown>(
    options?: RpcMutationOptionsInput<
      Rpc.SuccessExit<Current>,
      RpcProcedureError<Current>,
      Rpc.PayloadConstructor<Current>,
      TOnMutateResult
    >,
  ) => CreateMutationOptions<
    Rpc.SuccessExit<Current>,
    RpcProcedureError<Current>,
    Rpc.PayloadConstructor<Current>,
    TOnMutateResult
  >;
};

type RpcProcedureHelperFor<Current extends Rpc.Any> =
  RpcProcedureKindOf<Current> extends 'mutation'
    ? RpcMutationProcedureHelper<Current>
    : RpcQueryProcedureHelper<Current>;

type RpcHelpersFrom<Rpcs extends Rpc.Any, Prefix extends string> = {
  readonly [Current in Rpcs as Current['_tag'] extends `${Prefix}.${infer Method}`
    ? Method
    : Current['_tag']]: RpcProcedureHelperFor<Current>;
};

export type EffectRpcAngularClient<Rpcs extends Rpc.Any> = RpcHelpersFrom<
  RpcNonPrefixed<Rpcs>,
  ''
> & {
  readonly [Prefix in RpcPrefixes<Rpcs>]: RpcHelpersFrom<RpcPrefixed<Rpcs, Prefix>, Prefix>;
} & {
  readonly pathKey: (pathSegments: readonly string[], options?: RpcPathOptions) => RpcPathKey;
  readonly queryFilter: (
    pathSegments: readonly string[],
    options?: RpcQueryFilterOptions,
  ) => QueryFilters<RpcPathKey>;
};

export type EffectRpcAngularClientFactory<Rpcs extends Rpc.Any> = {
  readonly token: InjectionToken<EffectRpcAngularClient<Rpcs>>;
  readonly providers: EnvironmentProviders;
  readonly injectClient: () => EffectRpcAngularClient<Rpcs>;
};

const getPathSegments = (tag: string): readonly string[] => tag.split('.');

const resolveKeyPrefix = (
  base: RpcKeyPrefix | undefined,
  override: RpcKeyPrefix | undefined,
): RpcKeyPrefix | undefined => override ?? base;

const getProcedureKind = (rpc: Rpc.AnyWithProps): RpcProcedureKind => {
  const maybeKind = Context.getOption(rpc.annotations, RPC_PROCEDURE_KIND_ANNOTATION);

  if (Option.isSome(maybeKind) && maybeKind.value.kind === 'mutation') {
    return 'mutation';
  }

  return 'query';
};

const createStreamUnsupportedError = (tag: string): Error =>
  new Error(
    `RPC procedure "${tag}" returns a Stream and is not supported by this integration. ` +
      'Use a stream-specific integration path for this procedure.',
  );

const asRecord = (value: unknown): Record<string, unknown> | undefined =>
  typeof value === 'object' && value !== null ? (value as Record<string, unknown>) : undefined;

const resolveProcedureCall = <Current extends Rpc.Any>(
  client: unknown,
  pathSegments: readonly string[],
): ((
  input: Rpc.PayloadConstructor<Current>,
) => Effect.Effect<Rpc.SuccessExit<Current>, unknown, never>) => {
  let target: unknown = client;

  for (const segment of pathSegments) {
    const container = asRecord(target);
    if (!container || !(segment in container)) {
      throw new Error(
        `RPC procedure "${pathSegments.join('.')}" is missing on the generated client.`,
      );
    }
    target = container[segment];
  }

  if (typeof target !== 'function') {
    throw new Error(
      `RPC procedure "${pathSegments.join('.')}" resolved to a non-callable value on the generated client.`,
    );
  }

  return target as (
    input: Rpc.PayloadConstructor<Current>,
  ) => Effect.Effect<Rpc.SuccessExit<Current>, unknown, never>;
};

const assignNestedHelper = (
  root: Record<string, unknown>,
  pathSegments: readonly string[],
  helper: unknown,
): void => {
  if (pathSegments.length === 0) {
    return;
  }

  if (
    pathSegments.length === 1 &&
    (pathSegments[0] === 'pathKey' || pathSegments[0] === 'queryFilter')
  ) {
    throw new Error(
      `RPC procedure "${pathSegments[0]}" conflicts with a reserved root helper name in EffectRpcAngularClient.`,
    );
  }

  let cursor = root;

  for (let index = 0; index < pathSegments.length - 1; index += 1) {
    const segment = pathSegments[index]!;
    const existing = cursor[segment];

    if (existing === undefined) {
      const next: Record<string, unknown> = {};
      cursor[segment] = next;
      cursor = next;
      continue;
    }

    const existingContainer = asRecord(existing);
    if (!existingContainer) {
      throw new Error(
        `RPC procedure path "${pathSegments.join('.')}" conflicts with an existing non-object helper segment "${segment}".`,
      );
    }

    cursor = existingContainer;
  }

  const leaf = pathSegments[pathSegments.length - 1]!;
  cursor[leaf] = helper;
};

const createProcedureHelper = <Rpcs extends Rpc.Any, Current extends Rpcs>(
  config: EffectRpcAngularClientConfig<Rpcs>,
  group: RpcGroup.RpcGroup<Rpcs>,
  tag: string,
  rpc: Rpc.AnyWithProps,
): RpcProcedureHelperFor<Current> => {
  const pathSegments = getPathSegments(tag);
  const procedureKind = getProcedureKind(rpc);
  const streamUnsupportedError = RpcSchema.isStreamSchema(rpc.successSchema)
    ? createStreamUnsupportedError(tag)
    : undefined;

  const throwIfStreamProcedure = (): void => {
    if (streamUnsupportedError) {
      throw streamUnsupportedError;
    }
  };

  const callEffect = (input: Rpc.PayloadConstructor<Current>) => {
    throwIfStreamProcedure();

    const program = Effect.flatMap(RpcClient.make(group), (client) => {
      const call = resolveProcedureCall<Current>(client, pathSegments);
      return call(input);
    }).pipe(Effect.provide(config.rpcLayer), Effect.scoped);

    return program as Effect.Effect<Rpc.SuccessExit<Current>, RpcProcedureError<Current>, never>;
  };

  const call = (input: Rpc.PayloadConstructor<Current>) => Effect.runPromise(callEffect(input));

  const base: RpcProcedureBaseHelper<Current> = { call, callEffect };

  if (procedureKind === 'mutation') {
    const mutationKey = (options?: RpcMutationKeyOverrides) =>
      createRpcQueryKey(pathSegments, {
        keyPrefix: resolveKeyPrefix(config.keyPrefix, options?.keyPrefix),
        type: 'mutation',
      }) as RpcMutationKey;

    const mutationFn = () => async (input: Rpc.PayloadConstructor<Current>) => call(input);

    const mutationOptions = <TOnMutateResult = unknown>(
      options: RpcMutationOptionsInput<
        Rpc.SuccessExit<Current>,
        RpcProcedureError<Current>,
        Rpc.PayloadConstructor<Current>,
        TOnMutateResult
      > = {},
    ) =>
      createRpcMutationOptions({
        pathSegments,
        keyPrefix: resolveKeyPrefix(config.keyPrefix, options.keyPrefix),
        mutationFn: mutationFn() as RpcMutationFn<
          Rpc.SuccessExit<Current>,
          Rpc.PayloadConstructor<Current>,
          RpcProcedureError<Current>,
          TOnMutateResult
        >,
        defaults: config.mutationDefaults as RpcMutationOptionsOverrides<
          Rpc.SuccessExit<Current>,
          RpcProcedureError<Current>,
          Rpc.PayloadConstructor<Current>,
          TOnMutateResult
        >,
        overrides: options.overrides,
      });

    return {
      ...base,
      mutationKey,
      mutationFn,
      mutationOptions,
    } as unknown as RpcProcedureHelperFor<Current>;
  }

  const queryKey = (input: Rpc.PayloadConstructor<Current>, options?: RpcQueryKeyOverrides) =>
    createRpcQueryKey(pathSegments, {
      input,
      keyPrefix: resolveKeyPrefix(config.keyPrefix, options?.keyPrefix),
      type: 'query' satisfies RpcQueryKeyType,
    });

  const queryFn = (input: Rpc.PayloadConstructor<Current>) => () => call(input);

  const queryOptions = (
    input: Rpc.PayloadConstructor<Current>,
    options: RpcQueryOptionsInput<
      Rpc.PayloadConstructor<Current>,
      Rpc.SuccessExit<Current>,
      RpcProcedureError<Current>,
      Rpc.SuccessExit<Current>
    > = {},
  ) =>
    createRpcQueryOptions({
      pathSegments,
      input,
      keyPrefix: resolveKeyPrefix(config.keyPrefix, options.keyPrefix),
      type: 'query',
      queryFn: queryFn(input),
      defaults: config.queryDefaults as RpcQueryOptionsOverrides<
        Rpc.SuccessExit<Current>,
        RpcProcedureError<Current>,
        Rpc.SuccessExit<Current>,
        RpcQueryKey<Rpc.PayloadConstructor<Current>>
      >,
      overrides: options.overrides,
    });

  return {
    ...base,
    queryKey,
    queryFn,
    queryOptions,
  } as unknown as RpcProcedureHelperFor<Current>;
};

const createEffectRpcAngularClientInstance = <Rpcs extends Rpc.Any>(
  config: EffectRpcAngularClientConfig<Rpcs>,
): EffectRpcAngularClient<Rpcs> => {
  const root: Record<string, unknown> = {
    pathKey: (pathSegments: readonly string[], options: RpcPathOptions = {}) =>
      createRpcPathKey(pathSegments, {
        keyPrefix: options.keyPrefix ?? config.keyPrefix,
      }),
    queryFilter: (pathSegments: readonly string[], options: RpcQueryFilterOptions = {}) =>
      createRpcQueryFilter(pathSegments, {
        keyPrefix: options.keyPrefix ?? config.keyPrefix,
        exact: options.exact,
      }),
  };

  for (const [tag, rpc] of config.group.requests.entries()) {
    const helper = createProcedureHelper<Rpcs, Rpcs>(
      config,
      config.group,
      tag,
      rpc as unknown as Rpc.AnyWithProps,
    );
    assignNestedHelper(root, getPathSegments(tag), helper);
  }

  return root as EffectRpcAngularClient<Rpcs>;
};

export const createEffectRpcAngularClient = <Rpcs extends Rpc.Any>(
  input: EffectRpcAngularClientConfigInput<Rpcs>,
): EffectRpcAngularClientFactory<Rpcs> => {
  const config = createEffectRpcAngularClientConfig(input);
  const token = new InjectionToken<EffectRpcAngularClient<Rpcs>>('EFFECT_RPC_ANGULAR_CLIENT');

  const providers = makeEnvironmentProviders([
    {
      provide: token,
      useFactory: () => createEffectRpcAngularClientInstance(config),
    },
  ]);

  const injectClient = () => inject(token);

  return { token, providers, injectClient };
};
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-mutation-options.spec.ts">
import { createRpcMutationOptions } from './rpc-mutation-options';

describe('createRpcMutationOptions', () => {
  it('builds mutation options with mutationKey and mutationFn', () => {
    const mutationFn = async (input: { id: string }) => input.id;

    const options = createRpcMutationOptions({
      pathSegments: ['users', 'update'],
      mutationFn,
    });

    expect(options.mutationKey).toEqual([['users', 'update'], { type: 'mutation' }]);
    expect(options.mutationFn).toBe(mutationFn);
  });

  it('attaches rpc metadata with the procedure path', () => {
    const options = createRpcMutationOptions({
      pathSegments: ['users', 'update'],
      mutationFn: async () => 'ok',
    });

    expect(options.meta).toMatchObject({ rpc: { path: ['users', 'update'] } });
  });

  it('merges defaults with overrides', () => {
    const options = createRpcMutationOptions({
      pathSegments: ['users', 'update'],
      mutationFn: async () => 'ok',
      defaults: {
        retry: 1,
        meta: { source: 'default' },
      },
      overrides: {
        retry: 2,
        meta: { source: 'override', tags: ['a'] },
      },
    });

    expect(options.retry).toBe(2);
    expect(options.meta).toMatchObject({
      source: 'override',
      tags: ['a'],
      rpc: { path: ['users', 'update'] },
    });
  });

  it('supports keyPrefix', () => {
    const options = createRpcMutationOptions({
      pathSegments: ['users', 'update'],
      keyPrefix: ['app', 'v1'],
      mutationFn: async () => 'ok',
    });

    expect(options.mutationKey).toEqual([['app', 'v1', 'users', 'update'], { type: 'mutation' }]);
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-mutation-options.ts">
import type { CreateMutationOptions, DefaultError } from '@tanstack/angular-query-experimental';

import { createRpcQueryKey } from './rpc-query-key';
import type { RpcKeyPrefix } from './rpc-query-key';
import type { RpcMutationFn, RpcMutationKey } from './rpc-query-types';

export type RpcMutationMeta = {
  readonly path: readonly string[];
};

export type RpcMutationMetaEnvelope = {
  readonly rpc: RpcMutationMeta;
};

export type RpcMutationOptionsOverrides<TData, TError, TVariables, TOnMutateResult> = Omit<
  CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>,
  'mutationKey' | 'mutationFn'
>;

export type RpcMutationOptionsConfig<TData, TError, TVariables, TOnMutateResult> = {
  readonly pathSegments: readonly string[];
  readonly keyPrefix?: RpcKeyPrefix;
  readonly mutationFn: RpcMutationFn<TData, TVariables, TError, TOnMutateResult>;
  readonly defaults?: RpcMutationOptionsOverrides<TData, TError, TVariables, TOnMutateResult>;
  readonly overrides?: RpcMutationOptionsOverrides<TData, TError, TVariables, TOnMutateResult>;
};

/**
 * Builds TanStack Mutation options for an RPC procedure, merging defaults and overrides.
 */
export const createRpcMutationOptions = <
  TData,
  TError = DefaultError,
  TVariables = void,
  TOnMutateResult = unknown,
>(
  config: RpcMutationOptionsConfig<TData, TError, TVariables, TOnMutateResult>,
): CreateMutationOptions<TData, TError, TVariables, TOnMutateResult> => {
  const meta: RpcMutationMetaEnvelope & Record<string, unknown> = {
    ...(config.defaults?.meta ?? {}),
    ...(config.overrides?.meta ?? {}),
    rpc: { path: [...config.pathSegments] },
  };

  return {
    ...config.defaults,
    ...config.overrides,
    mutationKey: createRpcQueryKey(config.pathSegments, {
      keyPrefix: config.keyPrefix,
      type: 'mutation',
    }) as RpcMutationKey,
    mutationFn: config.mutationFn,
    meta,
  };
};
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-query-helpers.spec.ts">
import { TestBed } from '@angular/core/testing';
import { QueryClient } from '@tanstack/angular-query-experimental';
import { Rpc, RpcClient, RpcClientError, RpcGroup, RpcSchema } from '@effect/rpc';
import * as Effect from 'effect/Effect';
import * as Layer from 'effect/Layer';
import * as Schema from 'effect/Schema';

import { asRpcMutation, createEffectRpcAngularClient } from './effect-rpc-query-client';

const GetUser = Rpc.make('users.get', {
  payload: Schema.Struct({ id: Schema.String }),
  success: Schema.Struct({ name: Schema.String }),
});

const UpdateUserName = Rpc.make('users.updateName', {
  payload: Schema.Struct({ id: Schema.String, name: Schema.String }),
  success: Schema.Struct({ ok: Schema.Boolean }),
});

const UserEvents = Rpc.make('users.events', {
  payload: Schema.Struct({ id: Schema.String }),
  success: RpcSchema.Stream({ success: Schema.String, failure: Schema.Never }),
});

class AppRpcs extends RpcGroup.make(GetUser, asRpcMutation(UpdateUserName)) {}
class StreamRpcs extends RpcGroup.make(UserEvents) {}

const createFailingRpcLayer = (error: RpcClientError.RpcClientError) =>
  Layer.effect(
    RpcClient.Protocol,
    RpcClient.Protocol.make(() =>
      Effect.succeed({
        send: () => Effect.fail(error),
        supportsAck: false,
        supportsTransferables: false,
      }),
    ),
  );

describe('Effect RPC Angular client helpers', () => {
  it('builds query helpers and query options for query procedures', () => {
    const rpcClient = createEffectRpcAngularClient({
      group: AppRpcs,
      rpcLayer: createFailingRpcLayer(
        new RpcClientError.RpcClientError({ reason: 'Protocol', message: 'Not used' }),
      ),
      keyPrefix: 'app',
      queryDefaults: { staleTime: 5000 },
    });

    TestBed.configureTestingModule({ providers: [rpcClient.providers] });

    const client = TestBed.runInInjectionContext(() => rpcClient.injectClient());

    const key = client.users.get.queryKey({ id: '1' });
    expect(key).toEqual([['app', 'users', 'get'], { input: { id: '1' }, type: 'query' }]);

    const options = client.users.get.queryOptions({ id: '1' }, { overrides: { retry: 2 } });
    expect(options.queryKey).toEqual([
      ['app', 'users', 'get'],
      { input: { id: '1' }, type: 'query' },
    ]);
    expect(options.retry).toBe(2);
    expect(options.staleTime).toBe(5000);
    expect(options.meta).toMatchObject({ rpc: { path: ['users', 'get'] } });
  });

  it('builds mutation helpers and mutation options for mutation procedures', () => {
    const rpcClient = createEffectRpcAngularClient({
      group: AppRpcs,
      rpcLayer: createFailingRpcLayer(
        new RpcClientError.RpcClientError({ reason: 'Protocol', message: 'Not used' }),
      ),
      keyPrefix: ['app', 'v1'],
      mutationDefaults: { retry: 1 },
    });

    TestBed.configureTestingModule({ providers: [rpcClient.providers] });

    const client = TestBed.runInInjectionContext(() => rpcClient.injectClient());

    expect(client.users.updateName.mutationKey()).toEqual([
      ['app', 'v1', 'users', 'updateName'],
      { type: 'mutation' },
    ]);

    const options = client.users.updateName.mutationOptions({
      overrides: { retry: 2 },
    });

    expect(options.retry).toBe(2);
    expect(options.meta).toMatchObject({ rpc: { path: ['users', 'updateName'] } });
  });

  it('executes queryFn and mutationFn through the rpc layer', async () => {
    const error = new RpcClientError.RpcClientError({
      reason: 'Protocol',
      message: 'Test failure',
    });

    const rpcClient = createEffectRpcAngularClient({
      group: AppRpcs,
      rpcLayer: createFailingRpcLayer(error),
    });

    TestBed.configureTestingModule({ providers: [rpcClient.providers] });

    const client = TestBed.runInInjectionContext(() => rpcClient.injectClient());

    const queryFn = client.users.get.queryFn({ id: '1' });
    const queryKey = client.users.get.queryKey({ id: '1' });
    const queryContext = {
      client: new QueryClient(),
      queryKey,
      signal: new AbortController().signal,
      meta: undefined,
    };

    await expect(queryFn(queryContext)).rejects.toMatchObject({ message: 'Test failure' });

    const mutationFn = client.users.updateName.mutationFn();
    await expect(
      mutationFn({ id: '1', name: 'Ada' }, { client: new QueryClient(), meta: undefined }),
    ).rejects.toMatchObject({
      message: 'Test failure',
    });
  });

  it('builds path helpers for subtree invalidation', () => {
    const rpcClient = createEffectRpcAngularClient({
      group: AppRpcs,
      rpcLayer: createFailingRpcLayer(
        new RpcClientError.RpcClientError({ reason: 'Protocol', message: 'Not used' }),
      ),
      keyPrefix: ['app', 'v1'],
    });

    TestBed.configureTestingModule({ providers: [rpcClient.providers] });

    const client = TestBed.runInInjectionContext(() => rpcClient.injectClient());

    expect(client.pathKey(['users'])).toEqual([['app', 'v1', 'users']]);
    expect(client.queryFilter(['users'])).toEqual({ queryKey: [['app', 'v1', 'users']] });
  });

  it('throws explicit errors for stream procedures', () => {
    const rpcClient = createEffectRpcAngularClient({
      group: StreamRpcs,
      rpcLayer: createFailingRpcLayer(
        new RpcClientError.RpcClientError({ reason: 'Protocol', message: 'Not used' }),
      ),
    });

    TestBed.configureTestingModule({ providers: [rpcClient.providers] });

    const client = TestBed.runInInjectionContext(() => rpcClient.injectClient());

    expect(() => client.users.events.call({ id: '1' })).toThrow(/returns a Stream/);
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-query-key.spec.ts">
import { createRpcQueryKey } from './rpc-query-key';

describe('createRpcQueryKey', () => {
  it('returns path segments with empty metadata when no input is provided', () => {
    const key = createRpcQueryKey(['rpc', 'profile']);

    expect(key).toEqual([['rpc', 'profile'], {}]);
  });

  it('includes input in metadata when provided', () => {
    const key = createRpcQueryKey(['rpc', 'profile'], { input: { id: '42' } });

    expect(key).toEqual([['rpc', 'profile'], { input: { id: '42' } }]);
  });

  it('prepends keyPrefix when provided as a string', () => {
    const key = createRpcQueryKey(['rpc', 'profile'], { keyPrefix: 'app' });

    expect(key).toEqual([['app', 'rpc', 'profile'], {}]);
  });

  it('prepends keyPrefix when provided as segments', () => {
    const key = createRpcQueryKey(['rpc', 'profile'], { keyPrefix: ['app', 'v1'] });

    expect(key).toEqual([['app', 'v1', 'rpc', 'profile'], {}]);
  });

  it('passes through metadata type when provided', () => {
    const key = createRpcQueryKey(['rpc', 'profile'], { type: 'query' });

    expect(key).toEqual([['rpc', 'profile'], { type: 'query' }]);
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-query-key.ts">
import type { RpcQueryKey, RpcQueryKeyMeta, RpcQueryKeyType } from './rpc-query-types';

export type RpcKeyPrefix = string | readonly string[];

export type RpcQueryKeyOptions<TInput> = {
  readonly input?: TInput;
  readonly keyPrefix?: RpcKeyPrefix;
  readonly type?: RpcQueryKeyType;
};

const normalizeKeyPrefix = (keyPrefix?: RpcKeyPrefix): readonly string[] => {
  if (!keyPrefix) {
    return [];
  }
  return typeof keyPrefix === 'string' ? [keyPrefix] : keyPrefix;
};

const createMetadata = <TInput>(
  input: TInput | undefined,
  type: RpcQueryKeyType | undefined,
): RpcQueryKeyMeta<TInput> => {
  return {
    ...(input !== undefined ? { input } : {}),
    ...(type !== undefined ? { type } : {}),
  };
};

/**
 * Builds a TanStack Query key for RPC procedures with optional input metadata.
 */
export const createRpcQueryKey = <TInput>(
  pathSegments: readonly string[],
  options: RpcQueryKeyOptions<TInput> = {},
): RpcQueryKey<TInput> => {
  const prefix = normalizeKeyPrefix(options.keyPrefix);
  const combined = prefix.length > 0 ? [...prefix, ...pathSegments] : [...pathSegments];

  return [combined, createMetadata(options.input, options.type)];
};
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-query-options.spec.ts">
import { createRpcQueryOptions } from './rpc-query-options';

describe('createRpcQueryOptions', () => {
  it('builds query options with queryKey and queryFn', () => {
    const queryFn = async () => 'ok';

    const options = createRpcQueryOptions({
      pathSegments: ['rpc', 'profile'],
      queryFn,
    });

    expect(options.queryKey).toEqual([['rpc', 'profile'], {}]);
    expect(options.queryFn).toBe(queryFn);
  });

  it('attaches rpc metadata with the procedure path', () => {
    const options = createRpcQueryOptions({
      pathSegments: ['rpc', 'profile'],
      queryFn: async () => 'ok',
    });

    const meta = options.meta ?? {};

    expect(meta).toMatchObject({ rpc: { path: ['rpc', 'profile'] } });
  });

  it('merges defaults with overrides', () => {
    const queryFn = async () => 'ok';
    const options = createRpcQueryOptions({
      pathSegments: ['rpc', 'profile'],
      queryFn,
      defaults: {
        retry: 1,
        staleTime: 1000,
        meta: { source: 'default' },
      },
      overrides: {
        retry: 2,
        meta: { source: 'override', flags: ['a'] },
      },
    });

    expect(options.retry).toBe(2);
    expect(options.staleTime).toBe(1000);
    expect(options.meta).toMatchObject({
      source: 'override',
      flags: ['a'],
      rpc: { path: ['rpc', 'profile'] },
    });
  });

  it('supports keyPrefix and input metadata', () => {
    const options = createRpcQueryOptions({
      pathSegments: ['rpc', 'profile'],
      input: { id: '42' },
      keyPrefix: ['app', 'v1'],
      queryFn: async () => 'ok',
      type: 'query',
    });

    expect(options.queryKey).toEqual([
      ['app', 'v1', 'rpc', 'profile'],
      { input: { id: '42' }, type: 'query' },
    ]);
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-query-options.ts">
import type { CreateQueryOptions, DefaultError } from '@tanstack/angular-query-experimental';

import { createRpcQueryKey } from './rpc-query-key';
import type { RpcKeyPrefix } from './rpc-query-key';
import type { RpcQueryFn, RpcQueryKey, RpcQueryKeyType } from './rpc-query-types';

export type RpcQueryMeta = {
  readonly path: readonly string[];
};

export type RpcQueryMetaEnvelope = {
  readonly rpc: RpcQueryMeta;
};

export type RpcQueryOptionsOverrides<
  TQueryFnData,
  TError,
  TData,
  TQueryKey extends RpcQueryKey<unknown>,
> = Omit<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'queryKey' | 'queryFn'>;

export type RpcQueryOptionsConfig<TInput, TQueryFnData, TError, TData> = {
  readonly pathSegments: readonly string[];
  readonly input?: TInput;
  readonly keyPrefix?: RpcKeyPrefix;
  readonly type?: RpcQueryKeyType;
  readonly queryFn: RpcQueryFn<TQueryFnData, RpcQueryKey<TInput>>;
  readonly defaults?: RpcQueryOptionsOverrides<TQueryFnData, TError, TData, RpcQueryKey<TInput>>;
  readonly overrides?: RpcQueryOptionsOverrides<TQueryFnData, TError, TData, RpcQueryKey<TInput>>;
};

/**
 * Builds TanStack Query options for an RPC procedure, merging defaults and overrides.
 */
export const createRpcQueryOptions = <
  TInput,
  TQueryFnData,
  TError = DefaultError,
  TData = TQueryFnData,
>(
  config: RpcQueryOptionsConfig<TInput, TQueryFnData, TError, TData>,
): CreateQueryOptions<TQueryFnData, TError, TData, RpcQueryKey<TInput>> => {
  const meta: RpcQueryMetaEnvelope & Record<string, unknown> = {
    ...(config.defaults?.meta ?? {}),
    ...(config.overrides?.meta ?? {}),
    rpc: { path: [...config.pathSegments] },
  };

  return {
    ...config.defaults,
    ...config.overrides,
    queryKey: createRpcQueryKey(config.pathSegments, {
      input: config.input,
      keyPrefix: config.keyPrefix,
      type: config.type,
    }),
    queryFn: config.queryFn,
    meta,
  };
};
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-query-path.ts">
import type { QueryFilters } from '@tanstack/angular-query-experimental';

import { createRpcQueryKey } from './rpc-query-key';
import type { RpcKeyPrefix } from './rpc-query-key';

export type RpcPathKey = readonly [readonly string[]];

export type RpcPathOptions = {
  readonly keyPrefix?: RpcKeyPrefix;
};

export type RpcQueryFilterOptions = RpcPathOptions & {
  readonly exact?: boolean;
};

export const createRpcPathKey = (
  pathSegments: readonly string[],
  options: RpcPathOptions = {},
): RpcPathKey => {
  const key = createRpcQueryKey(pathSegments, { keyPrefix: options.keyPrefix });
  return [key[0]];
};

export const createRpcQueryFilter = (
  pathSegments: readonly string[],
  options: RpcQueryFilterOptions = {},
): QueryFilters<RpcPathKey> => {
  const filter: QueryFilters<RpcPathKey> = {
    queryKey: createRpcPathKey(pathSegments, { keyPrefix: options.keyPrefix }),
  };

  if (options.exact !== undefined) {
    filter.exact = options.exact;
  }

  return filter;
};
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-query-types.spec.ts">
import type {
  CreateMutationOptions,
  CreateQueryOptions,
  QueryFunction,
} from '@tanstack/angular-query-experimental';

import type {
  RpcMutationFn,
  RpcMutationKey,
  RpcMutationOptions,
  RpcQueryFn,
  RpcQueryKey,
  RpcQueryOptions,
} from './rpc-query-types';

describe('rpc query types', () => {
  it('aligns query options with TanStack CreateQueryOptions', () => {
    type SampleKey = RpcQueryKey<{ id: string }>;

    const options: RpcQueryOptions<string, Error, string, SampleKey> = {
      queryKey: [['users', 'detail'], { input: { id: '1' }, type: 'query' }],
      queryFn: async () => 'ok',
    };

    const assigned: CreateQueryOptions<string, Error, string, SampleKey> = options;

    expect(assigned.queryKey).toBe(options.queryKey);
  });

  it('exposes query functions compatible with TanStack QueryFunction', () => {
    type SampleKey = RpcQueryKey<{ id: string }>;

    const queryFn: RpcQueryFn<number, SampleKey> = async () => 42;
    const assigned: QueryFunction<number, SampleKey> = queryFn;

    expect(typeof assigned).toBe('function');
  });

  it('aligns mutation options with TanStack CreateMutationOptions', () => {
    const mutationOptions: RpcMutationOptions<string, Error, { id: string }, { snapshot: string }> =
      {
        mutationKey: [['users', 'update'], { type: 'mutation' }],
        mutationFn: async () => 'ok',
      };

    const assigned: CreateMutationOptions<string, Error, { id: string }, { snapshot: string }> =
      mutationOptions;

    expect(assigned.mutationKey).toEqual([['users', 'update'], { type: 'mutation' }]);
  });

  it('exposes mutation keys and functions with the expected shape', () => {
    const key: RpcMutationKey = [['users', 'update'], { type: 'mutation' }];
    const mutationFn: RpcMutationFn<number, { id: string }, Error, unknown> = async () => 42;

    expect(key[1].type).toBe('mutation');
    expect(typeof mutationFn).toBe('function');
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/lib/rpc-query-types.ts">
import type {
  CreateMutationOptions,
  CreateQueryOptions,
  DefaultError,
  MutationKey,
  QueryFunction,
  QueryKey,
} from '@tanstack/angular-query-experimental';

export type RpcQueryKeyType = 'query' | 'path' | 'mutation';

export type RpcQueryKeyMeta<TInput> = {
  readonly input?: TInput;
  readonly type?: RpcQueryKeyType;
};

export type RpcQueryKey<TInput = unknown> = readonly [readonly string[], RpcQueryKeyMeta<TInput>];

export type RpcQueryFn<
  TQueryFnData = unknown,
  TQueryKey extends QueryKey = QueryKey,
> = QueryFunction<TQueryFnData, TQueryKey>;

export type RpcQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>;

export type RpcMutationKey = readonly [readonly string[], { readonly type: 'mutation' }];

export type RpcMutationFn<
  TData = unknown,
  TVariables = unknown,
  TError = DefaultError,
  TOnMutateResult = unknown,
> = NonNullable<CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>['mutationFn']>;

export type RpcMutationOptions<
  TData = unknown,
  TError = DefaultError,
  TVariables = void,
  TOnMutateResult = unknown,
> = CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>;

export type RpcMutationKeyType = MutationKey;
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/testing/rpc-contracts.ts">
import * as Rpc from '@effect/rpc/Rpc';
import * as RpcGroup from '@effect/rpc/RpcGroup';
import * as Schema from 'effect/Schema';

import { asRpcMutation, asRpcQuery } from '../lib/effect-rpc-query-client';

export const GetUser = Rpc.make('users.get', {
  payload: Schema.Struct({ id: Schema.String }),
  success: Schema.Struct({ name: Schema.String }),
});

export const UpdateUserName = Rpc.make('users.updateName', {
  payload: Schema.Struct({ id: Schema.String, name: Schema.String }),
  success: Schema.Struct({ ok: Schema.Boolean }),
});

export class AppRpcs extends RpcGroup.make(asRpcQuery(GetUser), asRpcMutation(UpdateUserName)) {}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/oss-community-files.spec.ts">
import { existsSync, readFileSync } from 'node:fs';
import { join } from 'node:path';

const rootFile = (name: string): string => join(process.cwd(), name);

describe('OSS community and health files', () => {
  it('includes required root files for open-source collaboration', () => {
    expect(existsSync(rootFile('LICENSE'))).toBe(true);
    expect(existsSync(rootFile('CODE_OF_CONDUCT.md'))).toBe(true);
    expect(existsSync(rootFile('CONTRIBUTING.md'))).toBe(true);
  });

  it('uses an MIT license and documents reporting expectations', () => {
    const license = readFileSync(rootFile('LICENSE'), 'utf8');
    const contributing = readFileSync(rootFile('CONTRIBUTING.md'), 'utf8');

    expect(license).toContain('MIT License');
    expect(contributing).toContain('Reporting Bugs');
    expect(contributing).toContain('Open a GitHub issue');
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/package.spec.ts">
import packageJson from '../package.json';

type JsonRecord = Record<string, unknown>;
type PeerDependencies = Record<string, string>;

const isRecord = (value: unknown): value is JsonRecord =>
  typeof value === 'object' && value !== null;

const readPeerDependencies = (): PeerDependencies => {
  const parsed: unknown = packageJson;

  if (!isRecord(parsed)) {
    return {};
  }

  const peerDependencies = parsed['peerDependencies'];
  if (!isRecord(peerDependencies)) {
    return {};
  }

  const result: PeerDependencies = {};
  for (const [key, value] of Object.entries(peerDependencies)) {
    if (typeof value === 'string') {
      result[key] = value;
    }
  }

  return result;
};

describe('effect-angular-query package metadata', () => {
  it('declares required peer dependencies for the integration', () => {
    expect(readPeerDependencies()).toMatchObject({
      '@angular/common': expect.any(String),
      '@angular/core': expect.any(String),
      '@effect/rpc': expect.any(String),
      '@tanstack/angular-query-experimental': expect.any(String),
      effect: expect.any(String),
    });
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/public-api.spec.ts">
import * as PublicApi from './public-api';

describe('effect-angular-query public API', () => {
  it('exports the RPC client factory and classification helpers', () => {
    expect(PublicApi.createEffectRpcAngularClient).toBeTruthy();
    expect(PublicApi.createEffectRpcAngularClientConfig).toBeTruthy();
    expect(PublicApi.asRpcQuery).toBeTruthy();
    expect(PublicApi.asRpcMutation).toBeTruthy();
  });

  it('exports query and mutation utility helpers', () => {
    expect(PublicApi.createRpcQueryKey).toBeTruthy();
    expect(PublicApi.createRpcQueryOptions).toBeTruthy();
    expect(PublicApi.createRpcMutationOptions).toBeTruthy();
    expect(PublicApi.createRpcPathKey).toBeTruthy();
    expect(PublicApi.createRpcQueryFilter).toBeTruthy();
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/public-api.ts">
/*
 * Public API Surface of effect-angular-query
 */

export * from './lib/effect-rpc-query-client';
export * from './lib/rpc-mutation-options';
export * from './lib/rpc-query-key';
export * from './lib/rpc-query-options';
export * from './lib/rpc-query-path';
export * from './lib/rpc-query-types';
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/readme-examples.spec.ts">
import { TestBed } from '@angular/core/testing';
import {
  injectMutation,
  injectQuery,
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental';
import * as RpcClient from '@effect/rpc/RpcClient';
import * as Effect from 'effect/Effect';
import * as Layer from 'effect/Layer';

import { createEffectRpcAngularClient } from './lib/effect-rpc-query-client';
import { AppRpcs } from './testing/rpc-contracts';

const createRpcLayer = () =>
  Layer.effect(
    RpcClient.Protocol,
    RpcClient.Protocol.make(() =>
      Effect.succeed({
        send: () => Effect.succeed(undefined),
        supportsAck: false,
        supportsTransferables: false,
      }),
    ),
  );

const AppRpc = createEffectRpcAngularClient({
  group: AppRpcs,
  rpcLayer: createRpcLayer(),
  keyPrefix: 'app',
  queryDefaults: { staleTime: 10_000 },
  mutationDefaults: { retry: 1 },
});

describe('README examples', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        provideTanStackQuery(new QueryClient({ defaultOptions: { queries: { retry: false } } })),
        AppRpc.providers,
      ],
    });
  });

  it('creates an injectable client once and reuses it', () => {
    const first = TestBed.runInInjectionContext(() => AppRpc.injectClient());
    const second = TestBed.runInInjectionContext(() => AppRpc.injectClient());

    expect(first).toBe(second);
    expect(first.users.get.queryKey({ id: '1' })).toEqual([
      ['app', 'users', 'get'],
      { input: { id: '1' }, type: 'query' },
    ]);
  });

  it('uses query and mutation helpers with injectQuery and injectMutation', () => {
    const states = TestBed.runInInjectionContext(() => {
      const rpc = AppRpc.injectClient();

      const userQuery = injectQuery(() => rpc.users.get.queryOptions({ id: '1' }));
      const updateUser = injectMutation(() => rpc.users.updateName.mutationOptions());

      return { userQuery, updateUser };
    });

    expect(typeof states.userQuery.isPending).toBe('function');
    expect(typeof states.updateUser.mutate).toBe('function');
  });

  it('builds path helpers and mutation keys as documented', () => {
    const rpc = TestBed.runInInjectionContext(() => AppRpc.injectClient());

    expect(rpc.pathKey(['users'])).toEqual([['app', 'users']]);
    expect(rpc.queryFilter(['users'], { exact: false })).toEqual({
      queryKey: [['app', 'users']],
      exact: false,
    });
    expect(rpc.users.updateName.mutationKey()).toEqual([
      ['app', 'users', 'updateName'],
      { type: 'mutation' },
    ]);
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/readme.spec.ts">
import { readFileSync } from 'node:fs';
import { join } from 'node:path';

const readReadme = (): string =>
  readFileSync(join(process.cwd(), 'projects', 'effect-angular-query', 'README.md'), 'utf8');

describe('effect-angular-query README', () => {
  it('documents setup and usage for the unified RPC client helpers', () => {
    const readme = readReadme();
    expect(readme).toContain('Installation');
    expect(readme).toContain('createEffectRpcAngularClient');
    expect(readme).toContain('injectQuery');
    expect(readme).toContain('injectMutation');
    expect(readme).toContain('Query key');
    expect(readme).toContain('mutationOptions');
    expect(readme).toContain('Path helpers');
    expect(readme).toContain('injectable client');
    expect(readme).toContain('Sharing RPC contracts');
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/src/root-readme.spec.ts">
import { readFileSync } from 'node:fs';
import { join } from 'node:path';

const readRootReadme = (): string => readFileSync(join(process.cwd(), 'README.md'), 'utf8');

describe('root README', () => {
  it('documents workspace packages and Bun quickstart commands', () => {
    const readme = readRootReadme();

    expect(readme).toContain('## Quickstart');
    expect(readme).toContain('bun install');
    expect(readme).toContain('bun run build');
    expect(readme).toContain('## Packages');
    expect(readme).toContain('effect-platform-angular');
    expect(readme).toContain('effect-angular-query');
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/ng-package.json">
{
  "$schema": "../../node_modules/ng-packagr/ng-package.schema.json",
  "dest": "../../dist/effect-angular-query",
  "lib": {
    "entryFile": "src/public-api.ts"
  }
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/package.json">
{
  "name": "@heddendorp/effect-angular-query",
  "version": "0.1.1",
  "peerDependencies": {
    "@angular/common": "^21.1.0",
    "@angular/core": "^21.1.0",
    "@effect/rpc": "^0.73.0",
    "@tanstack/angular-query-experimental": "^5.90.25",
    "effect": "^3.19.15"
  },
  "dependencies": {
    "tslib": "^2.3.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/heddendorp/effect-angular.git",
    "directory": "projects/effect-angular-query"
  },
  "bugs": {
    "url": "https://github.com/heddendorp/effect-angular/issues"
  },
  "homepage": "https://github.com/heddendorp/effect-angular#readme",
  "publishConfig": {
    "access": "public"
  },
  "sideEffects": false
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/README.md">
# Effect Angular Query

Angular helpers for building an injectable Effect RPC client with auto-generated TanStack Query and Mutation options.

## Installation

```bash
npm install @heddendorp/effect-angular-query
```

```bash
bun add @heddendorp/effect-angular-query
```

Install required peers in your app:

```bash
bun add @tanstack/angular-query-experimental @effect/rpc effect
```

Requires Angular 21.x (peer dependency range currently `^21.1.0`).

## Setup

1. Provide TanStack Query:

```ts
import { ApplicationConfig } from '@angular/core';
import { provideTanStackQuery, QueryClient } from '@tanstack/angular-query-experimental';

export const appConfig: ApplicationConfig = {
  providers: [provideTanStackQuery(new QueryClient())],
};
```

2. Create and provide your RPC client once:

```ts
import { ApplicationConfig } from '@angular/core';
import * as Rpc from '@effect/rpc/Rpc';
import * as RpcClient from '@effect/rpc/RpcClient';
import * as RpcGroup from '@effect/rpc/RpcGroup';
import * as Layer from 'effect/Layer';
import * as Schema from 'effect/Schema';

import { asRpcMutation, createEffectRpcAngularClient } from '@heddendorp/effect-angular-query';

const GetUser = Rpc.make('users.get', {
  payload: Schema.Struct({ id: Schema.String }),
  success: Schema.Struct({ name: Schema.String }),
});

const UpdateUserName = asRpcMutation(
  Rpc.make('users.updateName', {
    payload: Schema.Struct({ id: Schema.String, name: Schema.String }),
    success: Schema.Struct({ ok: Schema.Boolean }),
  }),
);

class AppRpcs extends RpcGroup.make(GetUser, UpdateUserName) {}

const rpcLayer: Layer.Layer<RpcClient.Protocol, never, never> = createRpcLayer();

export const AppRpc = createEffectRpcAngularClient({
  group: AppRpcs,
  rpcLayer,
  keyPrefix: 'app',
  queryDefaults: { staleTime: 10_000 },
  mutationDefaults: { retry: 1 },
});

export const appConfig: ApplicationConfig = {
  providers: [AppRpc.providers],
};
```

## Sharing RPC contracts

Keep your RPC contract (schemas + `RpcGroup`) in a small shared package. The server imports it to
register handlers, while the client imports the same contract to type its helpers. This avoids
shipping server implementation code to the client while still sharing the RPC types.

## Usage with `injectQuery` and `injectMutation`

The injected client auto-exposes all procedures from your RPC group. New procedures become available
without creating extra services or manually wiring helper methods.

```ts
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { injectMutation, injectQuery, QueryClient } from '@tanstack/angular-query-experimental';

@Component({
  selector: 'app-user-details',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    @if (userQuery.isPending()) {
      <p>Loading...</p>
    } @else if (userQuery.isError()) {
      <p>Failed to load.</p>
    } @else {
      <p>{{ userQuery.data()?.name }}</p>
    }

    <button type="button" (click)="save()">Save</button>
  `,
})
export class UserDetailsComponent {
  private readonly rpc = AppRpc.injectClient();
  private readonly queryClient = inject(QueryClient);

  readonly userQuery = injectQuery(() => this.rpc.users.get.queryOptions({ id: '1' }));

  readonly updateUser = injectMutation(() =>
    this.rpc.users.updateName.mutationOptions({
      overrides: {
        onSuccess: () => this.queryClient.invalidateQueries(this.rpc.queryFilter(['users'])),
      },
    }),
  );

  save(): void {
    this.updateUser.mutate({ id: '1', name: 'Ada' });
  }
}
```

## Direct procedure calls

Each generated procedure also exposes direct call helpers:

- `call(input): Promise<Success>`
- `callEffect(input): Effect<Success, Error, never>`

```ts
await AppRpc.injectClient().users.updateName.call({ id: '1', name: 'Ada' });
```

## Query key and mutation helpers

### Query key

```ts
const rpc = AppRpc.injectClient();
const key = rpc.users.get.queryKey({ id: '1' });
// => [['app', 'users', 'get'], { input: { id: '1' }, type: 'query' }]
```

### mutationOptions and mutationKey

```ts
const rpc = AppRpc.injectClient();

const mutationOptions = rpc.users.updateName.mutationOptions();
const mutationKey = rpc.users.updateName.mutationKey();
```

## Typed expected errors

Expected errors are typed as the union of:

- your RPC schema error (`Rpc.ErrorExit<Procedure>`)
- `RpcClientError` transport/protocol errors.

This typed error union is reflected in `queryOptions` and `mutationOptions` callback types.

## Path helpers

Use path-level helpers to invalidate or refetch a subtree of queries:

```ts
const rpc = AppRpc.injectClient();
const filter = rpc.queryFilter(['users'], { exact: false });
```

## API reference

- `createEffectRpcAngularClient` - creates a typed injectable client factory (`providers`, `token`, `injectClient`).
- `createEffectRpcAngularClientConfig` - normalizes config defaults.
- `asRpcMutation` / `asRpcQuery` - marks procedure intent for generated helper surfaces.
- `createRpcQueryOptions` - build TanStack query options with RPC metadata.
- `createRpcMutationOptions` - build TanStack mutation options with RPC metadata.
- `createRpcQueryKey` - build query keys from path segments and input.
- `createRpcPathKey` / `createRpcQueryFilter` - path-level invalidation helpers.

## Migration from the previous API

This release includes a **major version bump** for `@heddendorp/effect-angular-query`.

### Old -> new mappings

- `provideEffectRpcQueryClient(...)` -> `const AppRpc = createEffectRpcAngularClient(...); AppRpc.providers`
- `inject(EffectRpcQueryClient)` -> `AppRpc.injectClient()`
- `rpcQueryClient.helpersFor(AppRpcs)` -> auto-exposed methods directly on `AppRpc.injectClient()`
- `helpers.users.get.queryOptions(...)` -> `AppRpc.injectClient().users.get.queryOptions(...)`

### Migration steps

1. Replace old provider setup with `createEffectRpcAngularClient(...)` and register `AppRpc.providers`.
2. Replace `EffectRpcQueryClient` injection with `AppRpc.injectClient()`.
3. Mark mutation procedures with `asRpcMutation(...)` so mutation helpers are generated.
4. Move old `defaults` into `queryDefaults` (and optionally `mutationDefaults`).
5. Update mutation call sites to use `injectMutation(() => rpc.<path>.mutationOptions())`.

## Stream procedures

Stream procedures are not supported in this integration surface. Generated helpers throw an explicit
error for procedures that return `RpcSchema.Stream`.

## injectable client

The recommended pattern is to create and provide one client in app setup and reuse it by calling
`AppRpc.injectClient()` in components and services.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/tsconfig.lib.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "../../out-tsc/lib",
    "declaration": true,
    "declarationMap": true,
    "types": []
  },
  "include": [
    "src/**/*.ts"
  ],
  "exclude": [
    "**/*.spec.ts"
  ]
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/tsconfig.lib.prod.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.lib.json",
  "compilerOptions": {
    "declarationMap": false
  },
  "angularCompilerOptions": {
    "compilationMode": "partial"
  }
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-angular-query/tsconfig.spec.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "../../out-tsc/spec",
    "resolveJsonModule": true,
    "types": [
      "vitest/globals",
      "node"
    ]
  },
  "include": [
    "src/**/*.d.ts",
    "src/**/*.spec.ts"
  ]
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/src/lib/effect-http-client.ts">
import { HttpClient as AngularHttpClient } from '@angular/common/http';
import { EnvironmentProviders, InjectionToken, inject, makeEnvironmentProviders } from '@angular/core';
import { HttpClient as EffectHttpClient } from '@effect/platform';
import * as Layer from 'effect/Layer';

import { createAngularHttpClient } from './http-client-adapter';

export const EFFECT_HTTP_CLIENT: InjectionToken<EffectHttpClient.HttpClient> =
  new InjectionToken<EffectHttpClient.HttpClient>('EFFECT_HTTP_CLIENT');

export const EFFECT_HTTP_CLIENT_LAYER: InjectionToken<
  Layer.Layer<EffectHttpClient.HttpClient, never, never>
> = new InjectionToken<Layer.Layer<EffectHttpClient.HttpClient, never, never>>(
  'EFFECT_HTTP_CLIENT_LAYER',
);

export const provideEffectHttpClient = (): EnvironmentProviders =>
  makeEnvironmentProviders([
    {
      provide: EFFECT_HTTP_CLIENT,
      useFactory: () => createAngularHttpClient(inject(AngularHttpClient)),
    },
  ]);

export const provideEffectHttpClientLayer = (): EnvironmentProviders =>
  makeEnvironmentProviders([
    {
      provide: EFFECT_HTTP_CLIENT_LAYER,
      useFactory: () => Layer.succeed(EffectHttpClient.HttpClient, inject(EFFECT_HTTP_CLIENT)),
    },
  ]);
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/src/lib/effect-platform-angular.spec.ts">
import { HttpClient, HttpRequest, provideHttpClient } from '@angular/common/http';
import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing';
import { TestBed } from '@angular/core/testing';
import * as Cause from 'effect/Cause';
import * as Exit from 'effect/Exit';
import * as Option from 'effect/Option';
import * as Stream from 'effect/Stream';
import { Headers, HttpBody, HttpClientError, HttpClientRequest } from '@effect/platform';
import * as Effect from 'effect/Effect';

import { EFFECT_HTTP_CLIENT, provideEffectHttpClient } from './effect-http-client';
import { createAngularHttpClient } from './http-client-adapter';

describe('Effect HTTP client provider', () => {
  it('registers the Effect HttpClient adapter via Angular DI', () => {
    TestBed.configureTestingModule({
      providers: [provideHttpClient(), provideEffectHttpClient()],
    });

    const client = TestBed.inject(EFFECT_HTTP_CLIENT);

    expect(client).toBeTruthy();
    expect(typeof client.execute).toBe('function');
  });

  it('exposes an adapter instance from Angular HttpClient', async () => {
    TestBed.configureTestingModule({
      providers: [provideHttpClient()],
    });

    const httpClient = TestBed.inject(HttpClient);
    const adapter = createAngularHttpClient(httpClient);
    const request = HttpClientRequest.get('https://example.test');

    const exit = await Effect.runPromiseExit(adapter.execute(request));

    expect(Exit.isFailure(exit)).toBe(true);
    if (Exit.isFailure(exit)) {
      const failure = Cause.failureOption(exit.cause);

      expect(Option.isSome(failure)).toBe(true);
      if (Option.isSome(failure)) {
        expect(failure.value).toBeInstanceOf(HttpClientError.RequestError);
      }
    }
  });
});

describe('Angular HttpClient adapter request mapping', () => {
  let adapter: ReturnType<typeof createAngularHttpClient>;
  let controller: HttpTestingController;
  // Helper to accommodate async Effect work before the HttpTestingController sees the request.
  const waitForRequest = async (
    matchFn: (req: HttpRequest<unknown>) => boolean,
  ): Promise<ReturnType<HttpTestingController['match']>[number]> => {
    for (let attempt = 0; attempt < 5; attempt += 1) {
      const matches = controller.match(matchFn);
      if (matches.length > 0) {
        return matches[0];
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    return controller.expectOne(matchFn);
  };

  beforeEach(() => {
    TestBed.resetTestingModule();
    TestBed.configureTestingModule({
      providers: [provideHttpClient(), provideHttpClientTesting()],
    });

    adapter = createAngularHttpClient(TestBed.inject(HttpClient));
    controller = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    controller.verify();
  });

  it('maps method and query params', async () => {
    const request = HttpClientRequest.get('https://example.test/api', {
      urlParams: { search: 'effect', page: 2 },
    });

    const response = Effect.runPromise(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.method === 'GET');
    const url = new URL(testRequest.request.urlWithParams);

    expect(url.pathname).toBe('/api');
    expect(url.searchParams.get('search')).toBe('effect');
    expect(url.searchParams.get('page')).toBe('2');

    testRequest.flush(new ArrayBuffer(0));
    await response;
  });

  it('maps headers', async () => {
    const request = HttpClientRequest.get('https://example.test/headers', {
      headers: { 'x-trace': 'trace-id', 'x-scope': 'adapter' },
    });

    const response = Effect.runPromise(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/headers');

    expect(testRequest.request.headers.get('x-trace')).toBe('trace-id');
    expect(testRequest.request.headers.get('x-scope')).toBe('adapter');

    testRequest.flush(new ArrayBuffer(0));
    await response;
  });

  it('maps response status and headers', async () => {
    const request = HttpClientRequest.get('https://example.test/status');
    const responsePromise = Effect.runPromise(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/status');

    testRequest.flush(new ArrayBuffer(0), {
      status: 201,
      statusText: 'Created',
      headers: { 'x-response': 'ok' },
    });

    const response = await responsePromise;
    const header = Headers.get(response.headers, 'x-response');

    expect(response.status).toBe(201);
    expect(Option.isSome(header)).toBe(true);
    if (Option.isSome(header)) {
      expect(header.value).toBe('ok');
    }
  });

  it('parses JSON response bodies', async () => {
    const request = HttpClientRequest.get('https://example.test/json');
    const responsePromise = Effect.runPromise(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/json');
    const payload = { ok: true };
    const bodyText = JSON.stringify(payload);
    const body = new ArrayBuffer(bodyText.length);
    const bodyView = new Uint8Array(body);
    for (let i = 0; i < bodyText.length; i += 1) {
      bodyView[i] = bodyText.charCodeAt(i);
    }

    testRequest.flush(body, {
      status: 200,
      statusText: 'OK',
      headers: { 'content-type': 'application/json' },
    });

    const response = await responsePromise;
    const parsed = await Effect.runPromise(response.json);

    expect(parsed).toEqual(payload);
  });

  it('maps body payloads', async () => {
    const body = HttpBody.text('hello', 'text/plain');
    const request = HttpClientRequest.post('https://example.test/body', { body });

    const response = Effect.runPromise(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/body');

    expect(testRequest.request.body).toEqual(body.body);
    expect(testRequest.request.headers.get('content-type')).toBe('text/plain');

    testRequest.flush(new ArrayBuffer(0));
    await response;
  });

  it('maps raw bodies', async () => {
    const request = HttpClientRequest.post('https://example.test/raw', {
      body: HttpBody.raw({ ok: true }),
    });

    const response = Effect.runPromise(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/raw');

    expect(testRequest.request.body).toEqual({ ok: true });

    testRequest.flush(new ArrayBuffer(0));
    await response;
  });

  it('maps form data bodies', async () => {
    const formData = new FormData();
    formData.append('name', 'effect');
    const request = HttpClientRequest.post('https://example.test/form', {
      body: HttpBody.formData(formData),
    });

    const response = Effect.runPromise(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/form');

    expect(testRequest.request.body).toBe(formData);

    testRequest.flush(new ArrayBuffer(0));
    await response;
  });

  it('maps stream bodies', async () => {
    const payload = new Uint8Array([1, 2, 3]);
    const streamBody = HttpBody.stream(Stream.fromIterable([payload]), 'application/octet-stream');
    const request = HttpClientRequest.post('https://example.test/stream', { body: streamBody });

    const response = Effect.runPromise(adapter.execute(request));
    await new Promise((resolve) => setTimeout(resolve, 0));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/stream');

    expect(Array.from(testRequest.request.body as Uint8Array)).toEqual([1, 2, 3]);

    testRequest.flush(new ArrayBuffer(0));
    await response;
  });

  it('surfaces transport errors as request failures', async () => {
    const request = HttpClientRequest.get('https://example.test/error');
    const exitPromise = Effect.runPromiseExit(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/error');

    testRequest.error(new ProgressEvent('error'));

    const exit = await exitPromise;

    expect(Exit.isFailure(exit)).toBe(true);
    if (Exit.isFailure(exit)) {
      const failure = Cause.failureOption(exit.cause);

      expect(Option.isSome(failure)).toBe(true);
      if (Option.isSome(failure)) {
        expect(failure.value).toBeInstanceOf(HttpClientError.RequestError);
      }
    }
  });

  it('maps status errors to Effect responses', async () => {
    const request = HttpClientRequest.get('https://example.test/status-error');
    const responsePromise = Effect.runPromise(adapter.execute(request));
    const testRequest = controller.expectOne((req) => req.url === 'https://example.test/status-error');

    testRequest.flush(new ArrayBuffer(0), {
      status: 500,
      statusText: 'Server Error',
      headers: { 'x-error': 'true' },
    });

    const response = await responsePromise;
    const header = Headers.get(response.headers, 'x-error');

    expect(response.status).toBe(500);
    expect(Option.isSome(header)).toBe(true);
    if (Option.isSome(header)) {
      expect(header.value).toBe('true');
    }
  });

  it('cancels in-flight requests when interrupted', async () => {
    const request = HttpClientRequest.get('https://example.test/cancel');
    const exitPromise = Effect.runPromiseExit(
      adapter.execute(request).pipe(Effect.timeout('1 millis')),
    );
    const testRequest = await waitForRequest((req) => req.url === 'https://example.test/cancel');

    const exit = await exitPromise;

    expect(Exit.isFailure(exit)).toBe(true);
    expect(testRequest.cancelled).toBe(true);
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/src/lib/effect-rpc-protocol-http-layer.spec.ts">
import { HttpRequest, provideHttpClient } from '@angular/common/http';
import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing';
import { TestBed } from '@angular/core/testing';
import * as Rpc from '@effect/rpc/Rpc';
import * as RpcClient from '@effect/rpc/RpcClient';
import * as RpcGroup from '@effect/rpc/RpcGroup';
import * as Schema from 'effect/Schema';
import * as Effect from 'effect/Effect';
import * as Exit from 'effect/Exit';

import {
  EFFECT_HTTP_CLIENT_LAYER,
  provideEffectHttpClient,
  provideEffectHttpClientLayer,
} from './effect-http-client';
import {
  EFFECT_RPC_PROTOCOL_HTTP_LAYER,
  provideEffectRpcProtocolHttpLayer,
} from './effect-rpc-protocol-http-layer';

const textDecoder = new TextDecoder();

const encodeText = (value: string): ArrayBuffer => {
  const buffer = new ArrayBuffer(value.length);
  const view = new Uint8Array(buffer);
  for (let i = 0; i < value.length; i += 1) {
    view[i] = value.charCodeAt(i);
  }
  return buffer;
};

const decodeBody = (body: unknown): string => {
  if (typeof body === 'string') {
    return body;
  }
  if (body instanceof ArrayBuffer) {
    return textDecoder.decode(body);
  }
  if (ArrayBuffer.isView(body)) {
    return textDecoder.decode(body);
  }
  if (body && typeof body === 'object') {
    const entries = Object.entries(body as Record<string, unknown>)
      .filter(([key]) => String(Number(key)) === key)
      .sort(([a], [b]) => Number(a) - Number(b));
    if (entries.length > 0) {
      const bytes = new Uint8Array(entries.length);
      for (const [key, byte] of entries) {
        bytes[Number(key)] = Number(byte);
      }
      return textDecoder.decode(bytes);
    }
  }

  return JSON.stringify(body);
};

const waitForRequest = async (
  controller: HttpTestingController,
  match: (req: HttpRequest<unknown>) => boolean,
) => {
  for (let attempt = 0; attempt < 5; attempt += 1) {
    const matches = controller.match(match);
    if (matches.length > 0) {
      return matches[0];
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
  return controller.expectOne(match);
};

const Ping = Rpc.make('Ping', {
  payload: Schema.Struct({ message: Schema.String }),
  success: Schema.Struct({ reply: Schema.String }),
});

class AppRpcs extends RpcGroup.make(Ping) {}

describe('Effect RPC protocol HTTP layer provider', () => {
  it('registers EFFECT_HTTP_CLIENT_LAYER via Angular DI', () => {
    TestBed.configureTestingModule({
      providers: [provideHttpClient(), provideEffectHttpClient(), provideEffectHttpClientLayer()],
    });

    const layer = TestBed.inject(EFFECT_HTTP_CLIENT_LAYER);

    expect(layer).toBeTruthy();
  });

  it('registers EFFECT_RPC_PROTOCOL_HTTP_LAYER via Angular DI', () => {
    TestBed.configureTestingModule({
      providers: [
        provideHttpClient(),
        provideEffectHttpClient(),
        provideEffectRpcProtocolHttpLayer({ url: '/rpc' }),
      ],
    });

    const layer = TestBed.inject(EFFECT_RPC_PROTOCOL_HTTP_LAYER);

    expect(layer).toBeTruthy();
  });

  it('routes RPC protocol HTTP requests through Angular HttpClient', async () => {
    TestBed.configureTestingModule({
      providers: [
        provideHttpClient(),
        provideHttpClientTesting(),
        provideEffectHttpClient(),
        provideEffectRpcProtocolHttpLayer({ url: '/rpc' }),
      ],
    });

    const controller = TestBed.inject(HttpTestingController);
    const layer = TestBed.inject(EFFECT_RPC_PROTOCOL_HTTP_LAYER);

    const responsePromise = Effect.runPromise(
      Effect.flatMap(RpcClient.make(AppRpcs), (client) => client.Ping({ message: 'ping' })).pipe(
        Effect.provide(layer),
        Effect.scoped,
      ),
    );

    const request = await waitForRequest(
      controller,
      (httpRequest) => httpRequest.url.endsWith('/rpc') && httpRequest.method === 'POST',
    );

    const decodedBody = JSON.parse(decodeBody(request.request.body)) as
      | {
          _tag: string;
          id: string;
          payload: { message: string };
        }
      | Array<{
          _tag: string;
          id: string;
          payload: { message: string };
        }>;
    const requestMessages = Array.isArray(decodedBody) ? decodedBody : [decodedBody];
    const exitPayload = Schema.encodeSync(Rpc.exitSchema(Ping))(Exit.succeed({ reply: 'pong' }));

    request.flush(
      encodeText(
        JSON.stringify([
          { _tag: 'Exit', requestId: requestMessages[0]?.id, exit: exitPayload },
        ]),
      ),
      {
        status: 200,
        statusText: 'OK',
        headers: { 'content-type': 'application/json' },
      },
    );

    expect(await responsePromise).toEqual({ reply: 'pong' });
    controller.verify();
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/src/lib/effect-rpc-protocol-http-layer.ts">
import { EnvironmentProviders, InjectionToken, inject, makeEnvironmentProviders } from '@angular/core';
import { HttpClient as EffectHttpClient } from '@effect/platform';
import * as RpcClient from '@effect/rpc/RpcClient';
import * as RpcSerialization from '@effect/rpc/RpcSerialization';
import * as Layer from 'effect/Layer';

import { EFFECT_HTTP_CLIENT } from './effect-http-client';

export type EffectRpcHttpLayerOptions = {
  readonly url: string | (() => string);
  readonly serializationLayer?: Layer.Layer<RpcSerialization.RpcSerialization, never, never>;
};

export const EFFECT_RPC_PROTOCOL_HTTP_LAYER: InjectionToken<
  Layer.Layer<RpcClient.Protocol, never, never>
> = new InjectionToken<Layer.Layer<RpcClient.Protocol, never, never>>(
  'EFFECT_RPC_PROTOCOL_HTTP_LAYER',
);

export const provideEffectRpcProtocolHttpLayer = (
  options: EffectRpcHttpLayerOptions,
): EnvironmentProviders =>
  makeEnvironmentProviders([
    {
      provide: EFFECT_RPC_PROTOCOL_HTTP_LAYER,
      useFactory: (): Layer.Layer<RpcClient.Protocol, never, never> => {
        const client = inject(EFFECT_HTTP_CLIENT);
        const serializationLayer = options.serializationLayer ?? RpcSerialization.layerJson;
        const url = typeof options.url === 'function' ? options.url() : options.url;

        return RpcClient.layerProtocolHttp({ url }).pipe(
          Layer.provide([
            serializationLayer,
            Layer.succeed(EffectHttpClient.HttpClient, client),
          ]),
        );
      },
    },
  ]);
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/src/lib/http-client-adapter.ts">
import {
  HttpClient as AngularHttpClient,
  HttpErrorResponse,
  HttpHeaders,
  HttpResponse,
} from '@angular/common/http';
import {
  HttpBody,
  HttpClient as EffectHttpClient,
  HttpClientError,
  type HttpClientRequest,
  HttpClientResponse,
} from '@effect/platform';
import * as Effect from 'effect/Effect';
import * as Stream from 'effect/Stream';

// Convert Effect stream bodies into a single Uint8Array payload for HttpClient.
const collectStreamBody = (
  request: HttpClientRequest.HttpClientRequest,
  body: HttpBody.Stream,
): Effect.Effect<Uint8Array, HttpClientError.RequestError> =>
  Effect.matchEffect(Effect.scoped(Stream.runFold(body.stream, new Uint8Array(0), appendChunk)), {
    onFailure: (cause) =>
      Effect.fail(
        new HttpClientError.RequestError({
          request,
          reason: 'Encode',
          cause,
        }),
      ),
    onSuccess: (payload) => Effect.succeed(payload),
  });

const appendChunk = (acc: Uint8Array, chunk: Uint8Array): Uint8Array => {
  const next = new Uint8Array(acc.length + chunk.length);
  next.set(acc, 0);
  next.set(chunk, acc.length);
  return next;
};

// Normalize Effect request bodies into something HttpClient can send.
const resolveBody = (
  request: HttpClientRequest.HttpClientRequest,
): Effect.Effect<unknown, HttpClientError.RequestError> => {
  const body = request.body;
  switch (body._tag) {
    case 'Empty':
      return Effect.succeed(undefined);
    case 'Raw':
      return Effect.succeed(body.body);
    case 'Uint8Array':
      return Effect.succeed(body.body);
    case 'FormData':
      return Effect.succeed(body.formData);
    case 'Stream':
      return collectStreamBody(request, body);
  }
};

// Preserve repeated response headers for the Fetch Response conversion.
const toHeaderEntries = (headers: HttpHeaders): Array<[string, string]> => {
  const entries: Array<[string, string]> = [];
  for (const name of headers.keys()) {
    const values = headers.getAll(name);
    if (!values) {
      continue;
    }
    for (const value of values) {
      entries.push([name, value]);
    }
  }
  return entries;
};

// Reuse the Effect response helpers by adapting HttpClient responses to Fetch Response.
const toEffectResponse = (
  request: HttpClientRequest.HttpClientRequest,
  response: HttpResponse<ArrayBuffer>,
): HttpClientResponse.HttpClientResponse => {
  const headers = toHeaderEntries(response.headers);
  const body = response.body ?? null;
  const webResponse = new Response(body, {
    status: response.status,
    statusText: response.statusText ?? '',
    headers,
  });
  return HttpClientResponse.fromWeb(request, webResponse);
};

export const createAngularHttpClient = (httpClient: AngularHttpClient): EffectHttpClient.HttpClient =>
  EffectHttpClient.make((request, url, signal) =>
    Effect.flatMap(resolveBody(request), (body) =>
      Effect.async((resume) => {
        const subscription = httpClient
          .request('' + request.method, url.toString(), {
            body,
            headers: new HttpHeaders(request.headers),
            observe: 'response',
            responseType: 'arraybuffer',
          })
          .subscribe({
            next: (response) => resume(Effect.succeed(toEffectResponse(request, response))),
            error: (cause) => {
              // HttpClient reports non-2xx statuses as HttpErrorResponse; map them into a response.
              if (cause instanceof HttpErrorResponse && cause.status !== 0) {
                const response = new HttpResponse<ArrayBuffer>({
                  body: (cause.error as ArrayBuffer | null) ?? null,
                  headers: cause.headers,
                  status: cause.status,
                  statusText: cause.statusText,
                  url: cause.url ?? undefined,
                });
                resume(Effect.succeed(toEffectResponse(request, response)));
                return;
              }

              resume(
                Effect.fail(
                  new HttpClientError.RequestError({
                    request,
                    reason: 'Transport',
                    cause,
                  }),
                ),
              );
            },
          });

        // Abort signals should cancel the in-flight HttpClient request.
        const abort = () => {
          subscription.unsubscribe();
        };

        if (signal.aborted) {
          abort();
        } else {
          signal.addEventListener('abort', abort, { once: true });
        }

        return Effect.sync(() => {
          signal.removeEventListener('abort', abort);
          subscription.unsubscribe();
        });
      }),
    ),
  );
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/src/public-api.spec.ts">
import { InjectionToken } from '@angular/core';

import * as PublicApi from './public-api';

describe('effect-platform-angular public API', () => {
  it('exports the Effect HttpClient provider API', () => {
    expect(PublicApi.EFFECT_HTTP_CLIENT).toBeTruthy();
    expect(PublicApi.EFFECT_HTTP_CLIENT).toBeInstanceOf(InjectionToken);
    expect(PublicApi.EFFECT_HTTP_CLIENT_LAYER).toBeTruthy();
    expect(PublicApi.EFFECT_HTTP_CLIENT_LAYER).toBeInstanceOf(InjectionToken);
    expect(PublicApi.provideEffectHttpClient).toBeDefined();
    expect(PublicApi.provideEffectHttpClientLayer).toBeDefined();
  });

  it('exports the Effect RPC protocol layer provider API', () => {
    expect(PublicApi.EFFECT_RPC_PROTOCOL_HTTP_LAYER).toBeTruthy();
    expect(PublicApi.EFFECT_RPC_PROTOCOL_HTTP_LAYER).toBeInstanceOf(InjectionToken);
    expect(PublicApi.provideEffectRpcProtocolHttpLayer).toBeDefined();
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/src/public-api.ts">
/*
 * Public API Surface of effect-platform-angular
 */

export * from './lib/effect-http-client';
export * from './lib/effect-rpc-protocol-http-layer';
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/src/rpc-example.spec.ts">
import { HttpClient, HttpRequest, provideHttpClient } from '@angular/common/http';
import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing';
import { Injectable, inject } from '@angular/core';
import { TestBed } from '@angular/core/testing';
import { HttpClient as EffectHttpClient } from '@effect/platform';
import { Rpc, RpcClient, RpcClientError, RpcGroup, RpcSerialization } from '@effect/rpc';
import * as Effect from 'effect/Effect';
import * as Exit from 'effect/Exit';
import * as Layer from 'effect/Layer';
import * as Schema from 'effect/Schema';

import { createAngularHttpClient } from './lib/http-client-adapter';

const textDecoder = new TextDecoder();

// Angular's HttpClient test harness works with ArrayBuffer; keep encoding explicit.
const encodeText = (value: string): ArrayBuffer => {
  const buffer = new ArrayBuffer(value.length);
  const view = new Uint8Array(buffer);
  for (let i = 0; i < value.length; i += 1) {
    view[i] = value.charCodeAt(i);
  }
  return buffer;
};

// Normalize the serialized request body so assertions stay stable across adapters.
const decodeBody = (body: unknown): string => {
  if (typeof body === 'string') {
    return body;
  }
  if (body instanceof ArrayBuffer) {
    return textDecoder.decode(body);
  }
  if (ArrayBuffer.isView(body)) {
    return textDecoder.decode(body);
  }
  if (body && typeof body === 'object') {
    const entries = Object.entries(body as Record<string, unknown>)
      .filter(([key]) => String(Number(key)) === key)
      .sort(([a], [b]) => Number(a) - Number(b));
    if (entries.length > 0) {
      const bytes = new Uint8Array(entries.length);
      for (const [key, byte] of entries) {
        bytes[Number(key)] = Number(byte);
      }
      return textDecoder.decode(bytes);
    }
  }
  return JSON.stringify(body);
};

// Minimal unary RPC used by both the service and the test.
const Ping = Rpc.make('Ping', {
  payload: Schema.Struct({ message: Schema.String }),
  success: Schema.Struct({ reply: Schema.String }),
});

class AppRpcs extends RpcGroup.make(Ping) {}

// Map Effect-returning procedures to promise-returning call sites (unary only).
type PromiseClient<T> = {
  -readonly [K in keyof T]: T[K] extends (...args: infer Args) => Effect.Effect<infer A, infer _E, infer _R>
    ? (...args: Args) => Promise<A>
    : never;
};

type RawClient = RpcClient.FromGroup<typeof AppRpcs, RpcClientError.RpcClientError>;
type AppRpcPromiseClient = PromiseClient<RawClient>;

// HttpTestingController can register requests asynchronously; poll a few ticks.
const waitForRequest = async (
  controller: HttpTestingController,
  match: (req: HttpRequest<unknown>) => boolean,
) => {
  for (let attempt = 0; attempt < 5; attempt += 1) {
    const matches = controller.match(match);
    if (matches.length > 0) {
      return matches[0];
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
  return controller.expectOne(match);
};

// Build a promise-based facade for unary RPC procedures in a single place.
const createPromiseClient = (
  layer: Layer.Layer<RpcClient.Protocol, never, never>,
): AppRpcPromiseClient => {
  const runRpc = <A, E>(call: (client: RawClient) => Effect.Effect<A, E, never>): Promise<A> => {
    const program = Effect.flatMap(RpcClient.make(AppRpcs), call).pipe(
      Effect.provide(layer),
      Effect.scoped,
    );

    return Effect.runPromise(program);
  };

  // Use RpcGroup metadata to expose the procedures without a Proxy.
  const client = {} as AppRpcPromiseClient;
  const procedureKeys = Array.from(AppRpcs.requests.keys()) as Array<keyof RawClient>;
  for (const key of procedureKeys) {
    client[key] = ((...args: Parameters<RawClient[typeof key]>) =>
      runRpc((rpcClient) => rpcClient[key](...args))) as AppRpcPromiseClient[typeof key];
  }

  return client;
};

@Injectable({ providedIn: 'root' })
class AppRpcClient implements AppRpcPromiseClient {
  // Adapter is created once per service instance and provided to Effect at call time.
  private readonly adapter = createAngularHttpClient(inject(HttpClient));
  private readonly rpcLayer: Layer.Layer<RpcClient.Protocol, never, never> =
    RpcClient.layerProtocolHttp({ url: '/rpc' }).pipe(
      Layer.provide([
        RpcSerialization.layerJson,
        Layer.succeed(EffectHttpClient.HttpClient, this.adapter),
      ]),
    );

  // Promise boundary for Angular components: expose procedures directly on the service.
  readonly Ping: AppRpcPromiseClient['Ping'];

  constructor() {
    const promiseClient = createPromiseClient(this.rpcLayer);
    this.Ping = promiseClient.Ping;
  }
}

describe('Effect RPC documentation example', () => {
  let controller: HttpTestingController;

  beforeEach(() => {
    TestBed.resetTestingModule();
    TestBed.configureTestingModule({
      providers: [provideHttpClient(), provideHttpClientTesting(), AppRpcClient],
    });

    controller = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    // Ensure no unexpected requests leak between test cases.
    controller.verify();
  });

  it('exposes a promise-returning RPC procedure via an Angular service', async () => {
    const service = TestBed.inject(AppRpcClient);
    const responsePromise = service.Ping({ message: 'ping' });

    const testRequest = await waitForRequest(
      controller,
      (req) => req.url.endsWith('/rpc') && req.method === 'POST',
    );

    // Confirm the client sends JSON over the HTTP RPC protocol endpoint.
    expect(testRequest.request.headers.get('content-type')).toBe('application/json');
    const decodedBody = JSON.parse(decodeBody(testRequest.request.body)) as
      | {
          _tag: string;
          id: string;
          payload: { message: string };
        }
      | Array<{
          _tag: string;
          id: string;
          payload: { message: string };
        }>;
    const requestMessages = Array.isArray(decodedBody) ? decodedBody : [decodedBody];

    expect(requestMessages[0]?._tag).toBe('Request');
    expect(requestMessages[0]?.payload).toEqual({ message: 'ping' });

    const exitPayload = Schema.encodeSync(Rpc.exitSchema(Ping))(Exit.succeed({ reply: 'pong' }));
    const responsePayload = [{ _tag: 'Exit', requestId: requestMessages[0]?.id, exit: exitPayload }];
    // Simulate the RPC server returning a successful Exit; the client should resolve it.
    testRequest.flush(encodeText(JSON.stringify(responsePayload)), {
      status: 200,
      statusText: 'OK',
      headers: { 'content-type': 'application/json' },
    });

    const parsed = await responsePromise;

    expect(parsed).toEqual({ reply: 'pong' });
  });
});
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/ng-package.json">
{
  "$schema": "../../node_modules/ng-packagr/ng-package.schema.json",
  "dest": "../../dist/effect-platform-angular",
  "lib": {
    "entryFile": "src/public-api.ts"
  }
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/package.json">
{
  "name": "@heddendorp/effect-platform-angular",
  "version": "0.0.7",
  "peerDependencies": {
    "@effect/platform": "^0.94.2",
    "@angular/common": "^21.1.0",
    "@angular/core": "^21.1.0",
    "effect": "^3.19.15"
  },
  "dependencies": {
    "tslib": "^2.3.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/heddendorp/effect-angular.git",
    "directory": "projects/effect-platform-angular"
  },
  "bugs": {
    "url": "https://github.com/heddendorp/effect-angular/issues"
  },
  "homepage": "https://github.com/heddendorp/effect-angular#readme",
  "publishConfig": {
    "access": "public"
  },
  "sideEffects": false
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/README.md">
# effect-platform-angular

Angular HttpClient adapter for Effect Platform. Use it to run Effect HttpClient requests with Angular's HttpClient and to power Effect RPC protocol layers in Angular apps.

## Quickstart

### Install

```bash
npm install @heddendorp/effect-platform-angular
```

```bash
bun add @heddendorp/effect-platform-angular
```

Install required peers in your app:

```bash
bun add @effect/platform effect
```

### Register the adapter

```ts
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { bootstrapApplication } from '@angular/platform-browser';
import {
  provideEffectHttpClient,
  provideEffectRpcProtocolHttpLayer,
} from '@heddendorp/effect-platform-angular';

import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient(withInterceptors([/* app interceptors */])),
    provideEffectHttpClient(),
    provideEffectRpcProtocolHttpLayer({ url: '/rpc' }),
  ],
});
```

Provider order matters: register `provideHttpClient(...)` first, then `provideEffectHttpClient()`, then `provideEffectRpcProtocolHttpLayer(...)`.

### Use the adapter in a service

```ts
import { inject, Injectable } from '@angular/core';
import { HttpClient } from '@effect/platform';
import * as Effect from 'effect/Effect';
import { EFFECT_HTTP_CLIENT } from '@heddendorp/effect-platform-angular';

@Injectable({ providedIn: 'root' })
export class ProfileService {
  private readonly httpClient = inject(EFFECT_HTTP_CLIENT);

  fetchProfile(id: string) {
    const request = HttpClient.get(`https://api.example.com/users/${id}`).pipe(
      Effect.provideService(HttpClient.HttpClient, this.httpClient),
      Effect.flatMap((response) => response.json),
    );

    return Effect.runPromise(request);
  }
}
```

## Concepts

- Adapter boundaries: `provideEffectHttpClient()` exposes an Effect HttpClient backed by Angular HttpClient.
- Layer boundaries: `provideEffectHttpClientLayer()` and `provideEffectRpcProtocolHttpLayer(...)` expose DI-provided Effect layers for direct `Layer` composition.
- Request mapping: `HttpBody` values become Angular request bodies; stream bodies are buffered into a `Uint8Array`.
- Response mapping: non-2xx HTTP responses are returned as `HttpClientResponse` values, while transport failures map to `HttpClientError.RequestError`.
- Cancellation: canceling an Effect fiber aborts the underlying HttpClient subscription.
- DI + Effect: inject `EFFECT_HTTP_CLIENT` and provide it to Effect with `Effect.provideService(HttpClient.HttpClient, client)`.

## Effect RPC (minimal example)

This example shows the intended path for using Effect RPC over HTTP with Angular. It assumes you have a server exposing the Effect RPC HTTP protocol at `/rpc` and that `@effect/rpc` is installed in your app. The Angular service is the boundary where you stop Effect-style handling and return Promises to components, so components can inject the client and call procedures directly.

If you also want auto-generated TanStack Query + Mutation helpers with one injectable client, use `@heddendorp/effect-angular-query` on top of this transport layer.

```ts
import { inject, Injectable } from '@angular/core';
import { Rpc, RpcClient, RpcClientError, RpcGroup } from '@effect/rpc';
import * as Effect from 'effect/Effect';
import * as Layer from 'effect/Layer';
import * as Schema from 'effect/Schema';
import { EFFECT_RPC_PROTOCOL_HTTP_LAYER } from '@heddendorp/effect-platform-angular';

const Ping = Rpc.make('Ping', {
  payload: Schema.Struct({ message: Schema.String }),
  success: Schema.Struct({ reply: Schema.String }),
});

export class AppRpcs extends RpcGroup.make(Ping) {}

type PromiseClient<T> = {
  -readonly [K in keyof T]: T[K] extends (
    ...args: infer Args
  ) => Effect.Effect<infer A, infer _E, infer _R>
    ? (...args: Args) => Promise<A>
    : never;
};

type RawClient = RpcClient.FromGroup<typeof AppRpcs, RpcClientError.RpcClientError>;
type AppRpcPromiseClient = PromiseClient<RawClient>;

const createPromiseClient = (
  layer: Layer.Layer<RpcClient.Protocol, never, never>,
): AppRpcPromiseClient => {
  const runRpc = <A, E>(call: (client: RawClient) => Effect.Effect<A, E, never>): Promise<A> => {
    const program = Effect.flatMap(RpcClient.make(AppRpcs), call).pipe(
      Effect.provide(layer),
      Effect.scoped,
    );

    return Effect.runPromise(program);
  };

  const client = {} as AppRpcPromiseClient;
  const procedureKeys = Array.from(AppRpcs.requests.keys()) as Array<keyof RawClient>;
  for (const key of procedureKeys) {
    client[key] = ((...args: Parameters<RawClient[typeof key]>) =>
      runRpc((rpcClient) => rpcClient[key](...args))) as AppRpcPromiseClient[typeof key];
  }

  return client;
};

@Injectable({ providedIn: 'root' })
export class AppRpcClient implements AppRpcPromiseClient {
  private readonly rpcLayer = inject(EFFECT_RPC_PROTOCOL_HTTP_LAYER);

  readonly Ping: AppRpcPromiseClient['Ping'];

  constructor() {
    const promiseClient = createPromiseClient(this.rpcLayer);
    this.Ping = promiseClient.Ping;
  }
}
```

## API reference

### Providers

- `provideEffectHttpClient(): EnvironmentProviders` - registers the Angular HttpClient adapter.
- `EFFECT_HTTP_CLIENT: InjectionToken<HttpClient.HttpClient>` - the adapter instance to inject and provide to Effect.
- `provideEffectHttpClientLayer(): EnvironmentProviders` - registers a DI-provided `Layer.succeed(HttpClient.HttpClient, client)` layer.
- `EFFECT_HTTP_CLIENT_LAYER: InjectionToken<Layer.Layer<HttpClient.HttpClient, never, never>>` - Effect HttpClient layer token.
- `provideEffectRpcProtocolHttpLayer(options): EnvironmentProviders` - registers an RPC protocol HTTP transport layer that uses `EFFECT_HTTP_CLIENT`.
- `EFFECT_RPC_PROTOCOL_HTTP_LAYER: InjectionToken<Layer.Layer<RpcClient.Protocol, never, never>>` - RPC protocol layer token.
- `EffectRpcHttpLayerOptions`:
  - `url: string | (() => string)` - endpoint URL (function form is resolved when Angular creates the layer).
  - `serializationLayer?: Layer.Layer<RpcSerialization.RpcSerialization, never, never>` - defaults to `RpcSerialization.layerJson`.

## Compatibility

- Angular 21.x (peer dependency range currently `^21.1.0`)
- `@effect/platform` 0.94+
- `effect` 3.19+
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/tsconfig.lib.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "../../out-tsc/lib",
    "declaration": true,
    "declarationMap": true,
    "types": []
  },
  "include": [
    "src/**/*.ts"
  ],
  "exclude": [
    "**/*.spec.ts"
  ]
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/tsconfig.lib.prod.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.lib.json",
  "compilerOptions": {
    "declarationMap": false
  },
  "angularCompilerOptions": {
    "compilationMode": "partial"
  }
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/projects/effect-platform-angular/tsconfig.spec.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "../../out-tsc/spec",
    "types": [
      "vitest/globals"
    ]
  },
  "include": [
    "src/**/*.d.ts",
    "src/**/*.spec.ts"
  ]
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/.editorconfig">
# Editor configuration, see https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single
ij_typescript_use_double_quotes = false

[*.md]
max_line_length = off
trim_trailing_whitespace = false
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/.gitignore">
# See https://docs.github.com/get-started/getting-started-with-git/ignoring-files for more about ignoring files.

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
!.vscode/mcp.json
.history/*

# Miscellaneous
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings
__screenshots__/

# System files
.DS_Store
Thumbs.db
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/AGENTS.md">
You are an expert in TypeScript, Angular, and scalable web application development. You write functional, maintainable, performant, and accessible code following Angular and TypeScript best practices.

## TypeScript Best Practices

- Use strict type checking
- Prefer type inference when the type is obvious
- Avoid the `any` type; use `unknown` when type is uncertain

## Angular Best Practices

- Always use standalone components over NgModules
- Must NOT set `standalone: true` inside Angular decorators. It's the default in Angular v20+.
- Use signals for state management
- Implement lazy loading for feature routes
- Do NOT use the `@HostBinding` and `@HostListener` decorators. Put host bindings inside the `host` object of the `@Component` or `@Directive` decorator instead
- Use `NgOptimizedImage` for all static images.
  - `NgOptimizedImage` does not work for inline base64 images.

## Accessibility Requirements

- It MUST pass all AXE checks.
- It MUST follow all WCAG AA minimums, including focus management, color contrast, and ARIA attributes.

### Components

- Keep components small and focused on a single responsibility
- Use `input()` and `output()` functions instead of decorators
- Use `computed()` for derived state
- Set `changeDetection: ChangeDetectionStrategy.OnPush` in `@Component` decorator
- Prefer inline templates for small components
- Prefer Reactive forms instead of Template-driven ones
- Do NOT use `ngClass`, use `class` bindings instead
- Do NOT use `ngStyle`, use `style` bindings instead
- When using external templates/styles, use paths relative to the component TS file.

## State Management

- Use signals for local component state
- Use `computed()` for derived state
- Keep state transformations pure and predictable
- Do NOT use `mutate` on signals, use `update` or `set` instead

## Templates

- Keep templates simple and avoid complex logic
- Use native control flow (`@if`, `@for`, `@switch`) instead of `*ngIf`, `*ngFor`, `*ngSwitch`
- Use the async pipe to handle observables
- Do not assume globals like (`new Date()`) are available.
- Do not write arrow functions in templates (they are not supported).

## Services

- Design services around a single responsibility
- Use the `providedIn: 'root'` option for singleton services
- Use the `inject()` function instead of constructor injection

## Release and Change Tracking

- Use changesets for tracking user-facing changes.
- Add a changeset file for each user-facing PR under `.changeset/`.
- Use valid changeset frontmatter in each file (`effect-platform-angular` and/or `effect-angular-query` with `patch|minor|major`), then a Markdown summary body.
- Do not rely on conventional commits alone for release notes.
- Keep changeset summaries concise and focused on user impact.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/angular.json">
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "cli": {
    "packageManager": "bun"
  },
  "newProjectRoot": "projects",
  "projects": {
    "effect-platform-angular": {
      "projectType": "library",
      "root": "projects/effect-platform-angular",
      "sourceRoot": "projects/effect-platform-angular/src",
      "prefix": "lib",
      "architect": {
        "build": {
          "builder": "@angular/build:ng-packagr",
          "configurations": {
            "production": {
              "tsConfig": "projects/effect-platform-angular/tsconfig.lib.prod.json"
            },
            "development": {
              "tsConfig": "projects/effect-platform-angular/tsconfig.lib.json"
            }
          },
          "defaultConfiguration": "production"
        },
        "test": {
          "builder": "@angular/build:unit-test",
          "options": {
            "tsConfig": "projects/effect-platform-angular/tsconfig.spec.json"
          }
        }
      }
    },
    "effect-angular-query": {
      "projectType": "library",
      "root": "projects/effect-angular-query",
      "sourceRoot": "projects/effect-angular-query/src",
      "prefix": "lib",
      "architect": {
        "build": {
          "builder": "@angular/build:ng-packagr",
          "configurations": {
            "production": {
              "tsConfig": "projects/effect-angular-query/tsconfig.lib.prod.json"
            },
            "development": {
              "tsConfig": "projects/effect-angular-query/tsconfig.lib.json"
            }
          },
          "defaultConfiguration": "production"
        },
        "test": {
          "builder": "@angular/build:unit-test",
          "options": {
            "tsConfig": "projects/effect-angular-query/tsconfig.spec.json"
          }
        }
      }
    }
  }
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on Keep a Changelog, and this project follows Semantic Versioning.
## 0.0.2 (2026-02-07)

### Features

- Add typed helper access
- Add query peer dependencies
- Update public API exports
- Add rpc query helpers
- Add rpc query client config
- Add rpc query options factory
- Add rpc query key builder
- Add rpc query type adapters
- map HttpClient responses
- map Effect requests to HttpClient
- add Effect HttpClient provider

### Fixes

- install deps before jsr dry-run in prepare workflow
- align knope config with required PR body and sync jsr versions
- use direct knope binary path during install step
- install knope from knope/v0.22.2 release tag
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/CHANGESETS.md">
# Change Files

Every user-facing pull request should include one new `.md` file in `.changeset/`.

Change files must use frontmatter with `package: change-type` pairs, then a Markdown summary.

This repo currently has two releasable packages in `knope.toml`:

- `effect-platform-angular`
- `effect-angular-query`

Valid change types:

- `patch`
- `minor`
- `major`

Example:

```md
---
effect-platform-angular: patch
effect-angular-query: major
---

### Added

- Initial public release of effect-platform-angular and effect-angular-query.

### Migration

- For breaking (`major`) changes, include explicit migration instructions with old -> new API mappings.
```
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/CODE_OF_CONDUCT.md">
# Code of Conduct

## Our Pledge

We as members, contributors, and maintainers pledge to make participation in
this project and our community a harassment-free experience for everyone,
regardless of age, body size, visible or invisible disability, ethnicity, sex
characteristics, gender identity and expression, level of experience,
education, socio-economic status, nationality, personal appearance, race,
religion, or sexual identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes
- Focusing on what is best for the overall community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or advances
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information without explicit permission
- Other conduct that could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Project maintainers are responsible for clarifying and enforcing standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior they deem inappropriate, threatening, offensive, or
harmful.

## Scope

This Code of Conduct applies within all project spaces and when an individual is
officially representing the project in public spaces.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the maintainers at security@effect-angular.dev. All complaints will
be reviewed and investigated promptly and fairly.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org),
version 2.1.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/CONTRIBUTING.md">
# Contributing

Thanks for your interest in contributing to Effect Angular.

## Development Setup

1. Install dependencies:
   ```bash
   bun install
   ```
2. Run tests:
   ```bash
   bun run test -- --watch=false
   ```
3. Build the workspace:
   ```bash
   bun run build
   ```

## Working on Packages

- `projects/effect-platform-angular`: Effect Platform integration with Angular HttpClient
- `projects/effect-angular-query`: Effect RPC injectable client with TanStack Query/Mutation helpers

Useful commands:

```bash
bun run ng test effect-platform-angular --watch=false
bun run ng test effect-angular-query --watch=false
bun run ng build effect-platform-angular
bun run ng build effect-angular-query
```

## Pull Requests

- Keep changes scoped and focused.
- Add or update tests when behavior changes.
- Update docs when API or workflows change.
- Use clear commit messages.
- Include a change file in `.changeset/` for user-facing changes.
- Use changeset frontmatter with package and change type, for example:

  ```md
  ---
  effect-platform-angular: patch
  effect-angular-query: major
  ---

  ### Changed

  - Explain user-visible impact.

  ### Migration

  - For breaking changes, include exact old -> new API replacements and setup steps.
  ```

## Releases

Release automation is managed by Knope and GitHub Actions.

### Prerequisites

- Configure a repository secret named `RELEASE_PAT` with:
  - `contents:write`
  - `pull-requests:write`
- Configure npm trusted publishing (OIDC) for:
  - `@heddendorp/effect-platform-angular`
  - `@heddendorp/effect-angular-query`
    linked to `heddendorp/effect-angular` release workflow.

### Standard release flow

1. Merge user-facing PRs with change files under `.changeset/`.
2. Wait for Knope Bot to create/update the `knope/release` pull request.
3. Review and merge the generated `knope/release` pull request.
4. Verify the **Release** workflow succeeds.
5. Confirm npm publishes for:
   - `@heddendorp/effect-platform-angular`
   - `@heddendorp/effect-angular-query`
6. Confirm both package versions are visible on npm.

### First release checklist

1. Ensure at least one change file exists in `.changeset/`.
2. Confirm `knope.toml` and workflow files are present.
3. Confirm `knope/release` pull request is present.
4. Merge `knope/release`.
5. Verify both npm package versions are published.

## Reporting Bugs

Open a GitHub issue with:

- Reproduction steps
- Expected behavior
- Actual behavior
- Environment details (Node, Bun, Angular versions)
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/git-town.toml">
# See https://www.git-town.com/configuration-file for details

[branches]
main = "main"

[hosting]
forge-type = "github"
github-connector = "gh"
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/knope.toml">
[packages.effect-platform-angular]
versioned_files = ["projects/effect-platform-angular/package.json"]

[packages.effect-angular-query]
versioned_files = ["projects/effect-angular-query/package.json"]

[changes]
ignore_conventional_commits = true

[bot.releases]
enabled = true
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/LICENSE">
MIT License

Copyright (c) 2026 Effect Angular contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/package.json">
{
  "name": "effect-angular",
  "version": "0.0.2",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build effect-platform-angular && ng build effect-angular-query",
    "watch": "ng build --watch --configuration development",
    "test": "ng test"
  },
  "prettier": {
    "printWidth": 100,
    "singleQuote": true,
    "overrides": [
      {
        "files": "*.html",
        "options": {
          "parser": "angular"
        }
      }
    ]
  },
  "private": true,
  "packageManager": "bun@1.2.19",
  "dependencies": {
    "@effect/platform": "^0.94.2",
    "@angular/common": "^21.1.0",
    "@angular/compiler": "^21.1.0",
    "@angular/core": "^21.1.0",
    "@angular/forms": "^21.1.0",
    "@angular/platform-browser": "^21.1.0",
    "@angular/router": "^21.1.0",
    "effect": "^3.19.15",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0"
  },
  "devDependencies": {
    "@angular/build": "^21.1.2",
    "@angular/cli": "^21.1.2",
    "@angular/compiler-cli": "^21.1.0",
    "@effect/rpc": "^0.73.0",
    "@tanstack/angular-query-experimental": "^5.90.25",
    "@types/node": "^22.10.2",
    "@vitest/coverage-v8": "^4.0.18",
    "jsdom": "^27.1.0",
    "ng-packagr": "^21.1.0",
    "typescript": "~5.9.2",
    "vitest": "^4.0.8"
  }
}
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/README.md">
# Effect Angular

Effect Angular provides Angular-first integrations for Effect Platform and Effect RPC.

## Overview

This workspace currently ships two Angular libraries:

- `effect-platform-angular`: Adapter that bridges Effect Platform `HttpClient` to Angular `HttpClient`.
- `effect-angular-query`: Injectable Effect RPC client with auto-generated TanStack Query and Mutation helpers.

## Goals

- Keep APIs idiomatic to Angular applications.
- Preserve strong Effect and TypeScript type-safety.
- Minimize setup overhead for HTTP and RPC usage in Angular.

## Requirements

- Node.js 22+ recommended
- Bun `1.2.x`
- Angular `21+`

## Quickstart

Install dependencies:

```bash
bun install
```

Build the workspace:

```bash
bun run build
```

Run tests:

```bash
bun run test -- --watch=false
```

## Packages

| Package                   | Purpose                                                             | Path                               |
| ------------------------- | ------------------------------------------------------------------- | ---------------------------------- |
| `effect-platform-angular` | Angular `HttpClient` adapter for Effect Platform HTTP/RPC transport | `projects/effect-platform-angular` |
| `effect-angular-query`    | Effect RPC client + TanStack Angular Query/Mutation helper layer    | `projects/effect-angular-query`    |

npm packages:

- `@heddendorp/effect-platform-angular`
- `@heddendorp/effect-angular-query`

Install from npm:

```bash
bun add @heddendorp/effect-platform-angular @heddendorp/effect-angular-query
```

Package-specific docs:

- `projects/effect-platform-angular/README.md`
- `projects/effect-angular-query/README.md`

## Development Commands

Run a project-specific test target:

```bash
bun run ng test effect-platform-angular --watch=false
bun run ng test effect-angular-query --watch=false
```

Build a specific library:

```bash
bun run ng build effect-platform-angular
bun run ng build effect-angular-query
```

## Release Workflow

This repository uses Knope with GitHub Actions for release automation.

- Change files live in `.changeset/` and are the source for release notes.
- Each change file uses frontmatter + summary markdown, for example:

  ```md
  ---
  effect-platform-angular: patch
  effect-angular-query: major
  ---

  ### Changed

  - Describe user-facing impact.

  ### Migration

  - For breaking changes, list explicit old -> new API replacements.
  ```

- Knope Bot updates/creates the `knope/release` pull request from `.changeset` files.
- Merging `knope/release` into `main` triggers the `Release` workflow, which runs tests/builds and publishes both libraries to npm.

Required repository secrets:

- `RELEASE_PAT` (recommended): Personal access token with `contents:write` and `pull-requests:write`.
  The workflows fall back to `GITHUB_TOKEN`, but `RELEASE_PAT` is recommended for reliable branch/PR operations.

Required npm setup:

- Configure both npm packages (`@heddendorp/effect-platform-angular`, `@heddendorp/effect-angular-query`) as trusted publishers linked to this GitHub repository/workflow (OIDC).

Manual first release bootstrap:

1. Add at least one change file in `.changeset/`.
2. Wait for Knope Bot to create/update the `knope/release` PR.
3. Merge the generated `knope/release` pull request.
4. Confirm the `Release` workflow succeeds and both npm packages publish successfully.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/release-smoke-test.md">
---
effect-platform-angular: patch
effect-angular-query: patch
---

Small maintenance release to validate the automated release workflow.
</file>

<file path="effect-angular-effect-platform-angular-v0.0.7/tsconfig.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "paths": {
      "@heddendorp/effect-angular-query": [
        "./dist/effect-angular-query"
      ],
      "@heddendorp/effect-platform-angular": [
        "./dist/effect-platform-angular"
      ]
    },
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "experimentalDecorators": true,
    "importHelpers": true,
    "target": "ES2022",
    "module": "preserve"
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  },
  "files": [],
  "references": [
    {
      "path": "./projects/effect-platform-angular/tsconfig.lib.json"
    },
    {
      "path": "./projects/effect-platform-angular/tsconfig.spec.json"
    },
    {
      "path": "./projects/effect-angular-query/tsconfig.lib.json"
    },
    {
      "path": "./projects/effect-angular-query/tsconfig.spec.json"
    }
  ]
}
</file>

</files>
